<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"/>
	<title>24.118: Orderings and the Higher Infinite</title>
	<meta name="author" content="Damien Rochford (based on notes by Agustín Rayo)"/>
	<link rel="stylesheet" type="text/css" href="philosstyle.css">
	<script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
</head>
<body>

<em class="philosophysmall"> 24.118:</em> <em
 class="titlesmall">Orderings and the Higher Infinite</em> <img style="padding-right:200px" src="Omega-exp-omega-labeled.svg" alt=
"A valiant attempt to illustrate, using lines for places in the ordering, \(\omega^\omega\). It&rsquo;s an infinite spiral downards, with every turn of the circle representing another power of \(\omega\)." width="30%" align="right">

<ul>
<li><a href="#section_large">Living Large</a>
<ul>
<li><a href="#section_power">Power Sets</a></li>
<li><a href="#section_unions">Unions</a></li>
<li><a href="#section_track">Keeping Track</a></li>
</ul></li>
<li><a href="#section_orderings">Orderings and Well-Orderings</a>

<ul>
<li><a href="#section_linear">Linear Orderings</a></li>
<li><a href="#section_well">Well Orderings</a></li>
</ul></li>
<li><a href="#section_types">Order Types</a>

<ul>
<li><a href="#section_shapes">The Shapes of Well-Orderings</a></li>
<li><a href="#section_wellwell">The Well-Orderings are Well-Ordered</a></li>
</ul></li>
<li><a href="#section_ordinals">Ordinals</a>

<ul>
<li><a href="#section_representative">Representatives</a></li>
<li><a href="#section_how">How the Ordinals are Ordered</a></li>
<li><a href="#section_which">Which Well-Ordering Does an Ordinal Represent?</a></li>
<li><a href="#section_official">The Official Definition</a></li>
</ul></li>
<li><a href="#section_arithmetic">Ordinal Arithmetic</a>

<ul>
<li><a href="#section_addition">Ordinal Addition</a></li>
<li><a href="#section_multiplication">Ordinal Mutliplication</a></li>
</ul></li>
<li><a href="#section_build">How to Build Large Sets Using Ordinals</a></li>
<li><a href="#section_senses">Two Different Senses of \(<\)</a></li>
<li><a href="#section_far">How Far Can You Go?</a>
	<ul><li><a href="#section_start">A Good Start</a></li>
		<li><a href="#section_nonrecursive">Non-Recursive Orderings</a></li>
		<li><a href="#section_uncountable">Ordinals with Uncountable Cardinalities</a></li>
		<li><a href="#section_cthulhu">Cthulhu</a></li>
	</ul></li>
</ul>

<h1 id="section_large">Living Large</h1>

<p>We’re going to talk about different sizes of infinity again. We are well familiar, now, with two sizes: \(|\mathbb{N}|\), and \(|\mathbb{R}|\). We also know that, for every set, there is a bigger one. But how big can you go, exactly?</p>

<p>You can go really, really, really big. We will only get started on how big you can go, in this unit; we won’t even get up to what are called the “small” large cardinals. But our glimpse of how big things can get will blow your mind.</p>

<p>We will need to develop a new tool to keep track of how enormously big we are getting; that tool is called an <em>ordinal</em>. But before we describe ordinals more formally, let me first give you a sense of where we’re going.</p>

<ul>

<h2 id="section_power">Power Sets</h2>

<p>Recall Cantor’s Theorem:\[|S| &lt; |\mathcal{P}(S)|\] …where \(S\) is an arbitrary set and \(\mathcal{P}(S)\) is the <em>power set</em> of \(S\) — i.e., the set of all subsets of \(S\). </p>

<p>It is an immediate consequence of Cantor’s Theorem that for any set, there is a bigger one — namely, its power set.</p>

<p>From Cantor’s Theorem it follows that there is a hierarchy of infinite cardinalities. You start with the cardinality of the natural numbers, take the power set of that, then the power set of that, and so on: 
	\[|\mathbb{N}| &lt; |\mathcal{P}(\mathbb{N})| &lt; |\mathcal{P}(\mathcal{P}(\mathbb{N}))| &lt; |\mathcal{P}(\mathcal{P}(\mathcal{P}(\mathbb{N})))| &lt; \ldots\]</p>

<p>We can recursively define \(\mathcal{P}^n(S)\) the following way: \[\mathcal{P}^0(S) = S\] and for \(n&gt;0\), \[\mathcal{P}^n(S)=\mathcal{P}(\mathcal{P}^{n-1}(S))\]
One way of getting bigger and bigger infinities is to choose bigger and bigger \(n\)s to make \(|\mathcal{P}^n(\mathbb{N})|\)</p>

<p>Just to give you a sense of what these sets are like:
<ul>
<li>\(\mathcal{P}^0(\mathbb{N})\) contains no sets; just natural numbers.<sup><a href="#fn:1" id="fnref:1" title="see footnote" class="footnote">1</a></sup></li>
<li>\(\mathcal{P}^1(\mathbb{N})\) contains the empty set, and sets of natural numbers, like this: \[\{3\}, \{0, 2987498000898, 32\}, \{0, 2, 4, 8, \ldots\}\]</li>
<li>\(\mathcal{P}^2(\mathbb{N})\) contains the empty set, the set containing the empty set, and sets of sets of natural numbers, like this: \[\{\{0\}\}, \{\{1, 3\}, \{0, 2, 4, 8,\ldots\}\}, \{\{27\}, \{2987498000898, 34, 25\}, \{1, 4, 9, 16,\ldots\}\}\]</li>
<li>And so on.</li></ul>
At each stage \(n\), the nesting of sets is equal to \(n\).</p>

<br>

<h2 id="section_unions">Unions</h2>

<p>That gets us <em>pretty</em> big — much, much bigger than the cardinality of the natural numbers. But what if we get sick of just using larger and larger \(n\)s for \(\mathcal{P}^n(\mathbb{N})\). Can we get bigger than \(\mathcal{P}^n(\mathbb{N})\) for any \(n\)?</p>

<p>How about \(\mathcal{P}^{|\mathbb{N}|}(\mathbb{N})\)? Sadly, no; that is not well defined. Each \(\mathcal{P}^n(\mathbb{N})\) is defined in terms of \(P^{n-1}(\mathbb{N})\), all the way back to \(P^0(\mathbb{N})\). But there is no \(\mathbb{N}-1\) to define \(\mathcal{P}^\mathbb{N}(\mathbb{N})\) in terms of.</p>

<p>But there <em>is</em> a trick to get a bigger set than any \(\mathcal{P}^n(\mathbb{N})\): we can take the <em>union</em> of all the \(\mathcal{P}^n(\mathbb{N})\)s — i.e., the set that contains all the elements of each \(\mathcal{P}^n(\mathbb{N})\). That is written as: \[\bigcup_{n \in \mathbb{N}} \mathcal{P}^n(\mathbb{N})\]</p>

<p>How do we know that \(\bigcup_{n \in \mathbb{N}} \mathcal{P}^n(\mathbb{N})\) is bigger than \(\mathcal{P}^n(\mathbb{N})\) for each \(n\)? Because it contains every set in \(\mathcal{P}^{n+1}(\mathbb{N})\), which is bigger than \(\mathcal{P}^n(\mathbb{N})\).</p>

<p>(Incidentally: unions are not generally bigger than the sets they are unions of. For example, as you know from problem set 3, the union of natural-numbers-many sets with cardinality \(|\mathbb{N}|\) has cardinality \(|\mathbb{N}|\). But in special cases like the one we are considering, where there is an infinite sequence of bigger and bigger sets, their union is always bigger than each member of the sequence.)</p>

<br>

<h2 id="section_track">Keeping Track</h2>

<p>Here is a list of the sets we have constructed so far, with each item on the list bigger than everything that comes earlier.

<center>
<table>
<tr><th style="text-align: center;">A set we can construct</th> <th style="text-align: center;">How that set is defined</th></tr>
<tr><td style="text-align: center;">\(\mathcal{P}^0(\mathbb{N})\)</td> <td style="text-align: center;">\(\mathbb{N}\) &mdash; i.e., \(\{x : x \mbox{ is a natural number}\}\)</td></tr>
<tr><td style="text-align: center;">\(\mathcal{P}^1(\mathbb{N})\)</td> <td style="text-align: center;">\(\mathcal{P}(\mathbb{N})\) &mdash; i.e., \(\{x : x \mbox{ is a subset of } \mathbb{N}\}\)</td></tr>
<tr><td style="text-align: center;">\(\mathcal{P}^2(\mathbb{N})\)</td> <td style="text-align: center;">\(\mathcal{P}(\mathcal{P}^1(\mathbb{N}))\)</td></tr>
<tr><td style="text-align: center;">\(\mathcal{P}^3(\mathbb{N})\)</td> <td style="text-align: center;">\(\mathcal{P}(\mathcal{P}^2(\mathbb{N}))\)</td></tr>
<tr><td style="text-align: center;">\(\vdots\)</td> <td style="text-align: center;">\(\vdots\)</td></tr>
<tr><td style="text-align: center;">\(\mathcal{P}^{k+1}(\mathbb{N})\)</td> <td style="text-align: center;">\(\mathcal{P}(\mathcal{P}^k(\mathbb{N}))\)</td></tr>
<tr><td style="text-align: center;">\(\vdots\)</td> <td style="text-align: center;">\(\vdots\)</td></tr>
<tr><td style="text-align: center;">\(\bigcup_{n \in \mathbb{N}} \mathcal{P}^n(\mathbb{N})\)</td> <td style="text-align: center;">\(\{x : x \in \mathcal{P}^n(\mathbb{N}) \mbox{ for some } n\in \mathbb{N}\}\)</td></tr>
</table>
</center>
</p>

<p>Could we construct even bigger sets? Of course we could!</p>

<p>We can start with the last item from the list above, apply the power set operation infinitely many times, then apply the union operation, then apply the power set operation infinitely many times, and so forth. If we keep doing that, we'll get all the sets on this infinitely big table:

<table style="width:90%">
<tr><td style="text-align: center;">\(\mathcal{P}^0(\mathbb{N})\)</td> <td style="text-align: center;">\(\bigcup_{n \in \mathbb{N}} \mathcal{P}^n(\mathbb{N})\)</td><td style="text-align: center;">\(\bigcup_{m \in \mathbb{N}}\mathcal{P}^m(\bigcup_{n \in \mathbb{N}} \mathcal{P}^n(\mathbb{N}))\)</td> <td style="text-align: center;">\(\bigcup_{l\in\mathbb{N}} \mathcal{P}^l(\bigcup_{m \in \mathbb{N}}\mathcal{P}^m(\bigcup_{n \in \mathbb{N}} \mathcal{P}^n(\mathbb{N})))\)</td><td style="text-align: center;">\(\ldots\)</td></tr>

<tr><td style="text-align: center;">\(\mathcal{P}^1(\mathbb{N})\)</td> <td style="text-align: center;">\(\mathcal{P}^1(\bigcup_{n \in \mathbb{N}} \mathcal{P}^n(\mathbb{N}))\)</td> <td style="text-align: center;">\(\mathcal{P}^1(\bigcup_{m \in \mathbb{N}}\mathcal{P}^m(\bigcup_{n \in \mathbb{N}} \mathcal{P}^n(\mathbb{N})))\)</td> <td style="text-align: center;">\(\mathcal{P}^1(\bigcup_{l\in\mathbb{N}} \mathcal{P}^l(\bigcup_{m \in \mathbb{N}}\mathcal{P}^m(\bigcup_{n \in \mathbb{N}} \mathcal{P}^n(\mathbb{N}))))\)</td> <td style="text-align: center;">\(\ldots\)</td></tr>

<tr><td style="text-align: center;">\(\mathcal{P}^2(\mathbb{N})\)</td> <td style="text-align: center;">\(\mathcal{P}^2(\bigcup_{n \in \mathbb{N}} \mathcal{P}^n(\mathbb{N}))\)</td> <td style="text-align: center;">\(\mathcal{P}^2(\bigcup_{m \in \mathbb{N}}\mathcal{P}^m(\bigcup_{n \in \mathbb{N}} \mathcal{P}^n(\mathbb{N})))\)</td> <td style="text-align: center;">\(\mathcal{P}^2(\bigcup_{l\in\mathbb{N}} \mathcal{P}^l(\bigcup_{m \in \mathbb{N}}\mathcal{P}^m(\bigcup_{m \in \mathbb{N}} \mathcal{P}^n(\mathbb{N}))))\)</td> <td style="text-align: center;">\(\ldots\)</td></tr>

<tr><td style="text-align: center;">\(\mathcal{P}^3(\mathbb{N})\)</td> <td style="text-align: center;">\(\mathcal{P}^3(\bigcup_{n \in \mathbb{N}} \mathcal{P}^n(\mathbb{N}))\)</td> <td style="text-align: center;">\(\mathcal{P}^3(\bigcup_{m \in \mathbb{N}}\mathcal{P}^m(\bigcup_{n \in \mathbb{N}} \mathcal{P}^n(\mathbb{N})))\)</td><td style="text-align: center;">\(\mathcal{P}^3(\bigcup_{l\in\mathbb{N}} \mathcal{P}^l(\bigcup_{m \in \mathbb{N}}\mathcal{P}^m(\bigcup_{n \in \mathbb{N}} \mathcal{P}^n(\mathbb{N}))))\)</td> <td style="text-align: center;">\(\ldots\)</tr>

<tr><td style="text-align: center;">\(\vdots\)</td> <td style="text-align: center;">\(\vdots\)</td><td style="text-align: center;">\(\vdots\)</td> <td style="text-align: center;">\(\vdots\)</td> <td style="text-align: center;">\(\ddots\)</td></tr>
</table></p>

<p>You should read this table starting at the top left; then go down the first (infinite) column, power-setting as you go. You move to the second column by union-ing everything in the first column, then you go down the second (infinite) column by power-setting. Then you move to the third column by unioning everything in the second column. And so on.</p>

<p>Could we get something bigger than anything on this table? Yes! We can take the union of <em>all</em> these sets, and get something bigger than any of them! It&rsquo;s a little hard to write that set down in standard notation, but I trust you get the idea.</p>

<p>Can we get something bigger than that? Yes! Power set it. Then power set it infinitely many times. Then union it. Then power set it infinitely many times. Then union. Keep doing that whole thing a natural numbers many times. Then union the lot. Then power set that infinitely many times. Then union that. Then power set infintely many times. Then union. Then keep doing that whole thing a natural numbers many times. Then union the whole lot. Then power set it&hellip;</p>

<p>The general procedure is clear enough: we can get bigger and bigger sets by combining applications of the power set operation with applications of the union operation in more and more ridiculous ways. But we have already met the limits of what can practically be written using the above notation. We need better tools, if we&rsquo;re going to keep track of where in the process of power-setting and unioning we are, if we want to specify really, really big sets.</p>

<p>The main objective of this topic is to show you those better tools, by introducing you to one of the most beautiful ideas in mathematics: ordinals. </p>

<p>Ordinals have to do with how sets are ordered; it turns out that there is a deep connection between how a set can be ordered and how to specify a big set. The connection won&rsquo;t be obvious for a while, so bear with me.</p>

</ul>

<br>

<h1 id="section_orderings">Orderings and Well-Orderings</h1>

<ul>

<h2 id="section_linear">Linear Orderings</h2>

<p>An ordering of a set is a way of ordering the elements of that set.</p>

<p>Generally speaking, there are many different ways of ordering the elements of a set. Take the set of my friends, for example. Its elements could be ordered by birth-date, or by telephone number, or by height.</p>

<p>Here we will be interested in orderings of a particular kind. They are sometimes called <em>linear orderings</em> (or <em>total orderings</em>). A linear ordering is just what you would expect: if a set of things is linearly ordered, the ordering defines a line of those things, with each one either before or after the others.</p>

<p>The usual ordering \(&lt;_I\) of the integers is a good example of a linear ordering: \[\ldots\ &lt;_\mathbb{Z} -2 &lt;_\mathbb{Z} -1 &lt;_\mathbb{Z} 0 &lt;_\mathbb{Z} 1 &lt;_\mathbb{Z} 2 &lt;_\mathbb{Z} 3 &lt;_\mathbb{Z} \ldots\]</p>

<p>Any two integers are such that one of them is bigger than the other (and therefore such that one of them is &ldquo;ahead&rdquo; of the other, according to \(&lt;_\mathbb{Z}\)).</p>

<p>Not every ordering is a linear ordering. Suppose we were to order people according to ancestry. In other words, we say that \(x &lt;_A y\) just in case \(y\) is an ancestor of \(x\). The relation \(&lt;_A\) is not a linear ordering because there are people — me and my brother, for instance — such that neither is an ancestor of the other (and therefore such that neither of them is &ldquo;ahead&rdquo; of the other, according to \(&lt;_A\)).</p>

<p>Here is how to define linear orderings formally (though this won’t matter so much for our purposes, so don’t worry if you don’t find this helpful).</p>

<p>An <strong>ordering</strong> of a set \(A\) is a relation on the elements of \(A\) such that:</p>

<ol>
<li><p><strong>Anti-Symmetry</strong><br>
For any \(a,b\in A\), if \(a&lt;b\) , then not-\((b&lt;a)\).</p></li>
<li><p><strong>Transitivity</strong><br>
For any \(a,b,c\in A\), if \(a&lt;b\) and \(b&lt;c\), then \(a&lt;c\).</p></li>
</ol>

<p>You need to add one more condition to make an ordering a <strong>linear ordering</strong>; it is this:</p>

<ol start="3">
<li><strong>Totality</strong><br>
For any \(a,b\in A\), if \(a\neq b\), then either \(a&lt;b\) or \(b&lt;a\).</li>
</ol>

<br>

<h2 id="section_well">Well-Orderings</h2>

<p>We just narrowed down the range of orderings we are interested in to the linear orderings. Now we will narrow down things even further, to a special sub-set of the linear orderings: the <em>well-orderings</em>.</p>

<p>A well-ordering of \(A\) is a linear ordering of \(A\) with the additional property that every non-empty subset of \(A\) has a smallest element.</p>

<p>Formally:</p>

<p>\(A\) is well-ordered by \(&lt;\) (or: \(&lt;\) is a <strong>well-ordering</strong> of \(A\)) if and only if:</p>

<ul>
<li>\(&lt;\) is a linear ordering of \(A\); and</li>
<li>for every non-empty subset \(S\) of \(A\), there is some element \(x \in S\) such that, for every \(y \in S\), if \(x \neq y\), then \(x&lt;y\).</li>
</ul>

<p>The usual ordering of the natural numbers, for example, is a well-ordering, since every non-empty set of natural numbers has a smallest element. But the usual ordering of the integers is not a well-ordering, since there are sets of integers with no smallest element (the set of all integers, for example).</p>

</ul>

<br>

<h1 id="section_types">Order Types</h1>

<ul>

<h2 id="section_shapes">The Shapes of Well-Orderings</h2>

<p>There are <em>lots</em> of ways of well-ordering the natural numbers. There is, of course, the usual ordering, which we&rsquo;ll write down as &ldquo;\(&lt;_\mathbb{N}\)&rdquo;: \[0&lt;_\mathbb{N}1&lt;_\mathbb{N}2&lt;_\mathbb{N}3&lt;_\mathbb{N}\ldots\]</p>

<p>But here’s another well-ordering: it’s just like the usual ordering, except that 0 and 1 get flipped around: \[1&lt;_a0&lt;_a2&lt;_a3&lt;_a4&lt;_a5&lt;_a\ldots\]</p>

<p>Although \(&lt;_\mathbb{N}\) and \(&lt;_a\) correspond to different ways of ordering the natural numbers, they have the “same shape”, which we might represent like this:
<center>
| | | | | …
</center></p>

<p>Another way of putting this: the two orderings are <em>isomorphic</em> to one another. A little more precisely: two well-orderings are isomorphic to one another when the following is true: you can get from one ordering to the other by switching around which elements are in which positions, but without changing the way in which the positions themselves are arranged.</p>

<p>(Formally: two orderings \(&lt;_1\) and \(&lt;_2\) are <strong>isomorphic</strong> to one another if and only if there exists a bijection \(f\) between the domain of \(&lt;_1\) and the domain of \(&lt;_2\) such that, for every \(x\) and \(y\) in the domain of \(&lt;_1\), we have \(x&lt;_1y\) if and only if \(f(x)&lt;_2f(y)\).)</p>

<p>If you have a finite set, all well-orderings of that set will be isomorphic to one another. But things are different when we are ordering infinite sets. To see this, let consider another well-ordering of the natural numbers, which we&rsquo;ll call &ldquo;\(&lt;_0\)&rdquo;. \(&lt;_0\) is the ordering in which zero is counted as bigger than every positive integer but the remaining numbers are ordered in the usual way: \[1&lt;_02&lt;_03&lt;_04&lt;_0\ldots&lt;_00\]</p>

<p>the natural numbers ordered by \(&lt;_0\) have following shape:</p>

<center>
| | | | | … |
</center>

which is different from the shape generated by \(&lt;_\mathbb{N}\):
<center>
| | | | | …
</center></p>

<p>So \(&lt;_0\) is not isomorphic to \(&lt;_\mathbb{N}\). There is no way of getting from one well-ordering to the other by switching around numbers without changing the way in which the positions of those numbers are themselves arranged.</p>

<p>In this topic we won’t be interested in particular orderings, such as \(&lt;_\mathbb{N}\) or \(&lt;_0\). Instead, we will be focusing on <em>types</em> of well-orderings, or <strong>order types</strong>. Different well-order types have different shapes.</p>

<br>

<h2 id="section_wellwell">The Well-Order Types are Well-Ordered</h2>

<p>We start with the well-order types of finite sets. Those are easy. The first one is the ordering of the empty set, which has the following shape:
<br>
<br>
<br>
— i.e., not shape at all. The next is the ordering of sets with one element in them. It looks like this:
<blockquote>
|
</blockquote>
Then the ordering of the set with two-elements:
<blockquote>
||
</blockquote>
and so on, for every natural number. Then you have the standard ordering the set of natural numbers:
<blockquote>
|||…
</blockquote>
Then that one plus another place at the end:
<blockquote>
|||…|
</blockquote>
and another…
<blockquote>
|||…||
</blockquote>
and so on…
<blockquote>
|||…|||…
</blockquote>
and then
<blockquote>
|||…|||…|
</blockquote>
…and so on. </p>

<p>Here is something to notice about the order types we’ve described so far: each earlier one is an <em>initial segment</em> of a later one. | is and initial segment of ||, which is an initial segment of |||||||||, which is an intitial segment of |||…, which is an initial segment of |||…||, and so on. And this is true in general, for all well-order types. That is: for any two well-order types, one is an initial segment of the other.</p>

<p>That means we can <em>order</em> the well-order types, by the initial segment relation. In fact, that ordering is a well-ordering! That is super nice, because it means we can go through the well-orderings without missing any, and in a way where it is clear which is further along than which. That will be helpful, later, when we use the well-order types to keep track of infinities. It also means that the well-order types have a structure somewhat like the natural numbers, so we can use similar tricks to those we use with the natural numbers to name well-order types really far along the ordering. That will be helpdul, later, when we use the well-order types to specify really big infinities.</p>

</uL>

<h1 id="section_ordinals">Ordinals</h1>

<p>The last well-ordering we got up to was
<blockquote>
|||…|||…|
</blockquote>
i.e., an omega sequence, followed by a second omega-sequence, followed by one position at the end.</p>

<p>We can keep going, obviously:
<blockquote>
|||…|||…|||…
</blockquote></p>

<p>And we can do that as long as we like:
<blockquote>
|||…|||…|||…|||…|||…|||…
</blockquote></p>

<p>But then maybe we get sick of that trick, and we go to a well-ordering past all of the ones like those above. At this point it gets difficult to draw a perspicuous diagram with lines and dots, but here is an attempt:
<blockquote>
(|||…|||…|||…|||…)…
</blockquote>
In the above well-order type, there is as many omega sequences as natural numbers, one after another.</p>

<p>Of course, we can keep going! We can add one more poisition after that:</p>
<blockquote>
(|||…|||…|||…|||…)…|
</blockquote>
and we can keep re-iterating all the way up:
<blockquote>
(|||…|||…|||…|||…)…(|||…|||…|||…)…(||||…|||…|||…)
</blockquote>
The order-type above has an omega sequence of omega sequences, followed by and omega sequence of omega sequences, followed by a third omega sequence of omega sequences.</p>

<p>But now we’re getting sick of our old tricks, so we do this:

<blockquote>
((|||…|||…|||…|||…)…(|||…|||…|||…)…(||||…|||…|||…))…</p>
</blockquote>
i.e., we form an omega sequence of omega sequences of omega sequences</p>

<p>And then add one more:
<blockquote>
((|||…|||…|||…|||…)…(|||…|||…|||…)…(||||…|||…|||…)…)…|
</blockquote>

<p>You see how this goes, maybe, but you also see how this is getting out of hand. If we want to get very far in describing order types in the above hierarchy, then lines and dots, though an improvement on describing well-order types in English, are not going to cut it. That’s why we use ordinals.</p>

<br>

<ul>

<h2 id="section_representative">Representatives</h2>

<p>And what is an ordinal? It is just a set, of a certain kind, which we use to <em>represent</em> a well-order type. You’ll get the basic idea by looking at this table:
<center>
<table width="50%">
	<tr> <th style="text-align:left">The well-order type with shape…</th> <th style="text-align:left">is represented by the ordinal…</th> <th style="text-align:left">which we shall call…</th> </tr>
	<tr> <td></td> <td>\(\{\}\)</td> <td>\(0_o\)</td> </tr>
	<tr> <td>|</td> <td>\(\{0_o\}\)</td> <td>\(1_o\)</td> </tr>
	<tr> <td>||</td> <td>\(\{0_o,1_o\}\)</td> <td>\(2_o\)</td> </tr>
	<tr> <td>|||</td> <td>\(\{0_o,1_o,2_o\}\)</td> <td>\(3_o\)</td> </tr>
	<tr> <td>||||</td> <td>\(\{0_o,1_o,2_o,3_o\}\)</td> <td>\(4_o\)</td> </tr>
	<tr> <td>etc.</td> <td>etc.</td> <td>etc.</td> </tr>
	<tr> <td>||||…</td> <td>\(\{0_o,1_o,2_o,3_o,\ldots\}\)</td> <td>\(\omega\)</td> </tr>
	<tr> <td>||||…|</td> <td>\(\{0_o,1_o,2_o,3_o,\ldots,\omega\}\)</td> <td>\(\omega+1_o\)</td> </tr>
	<tr> <td>||||…||</td> <td>\(\{0_o,1_o,2_o,3_o,\ldots,\omega,\omega+1_o\}\)</td> <td>\(\omega+2_o\)</td> </tr>
	<tr> <td>etc.</td> <td>etc.</td> <td>etc.</td> </tr>
</table></p>
</center>

<p>The best way to understand the hierarchy of ordinals is to think of it as built in stages, in accordance with the following principle:
<blockquote>
<strong>Construction Principle</strong><br>
At each stage of the process, introduce a new ordinal, which is the set of all ordinals that have been introduced at previous stages of the process.
</blockquote></p>

<p>Consider the initial stage of the process. Our principle tells us to introduce the set of every ordinal that’s been introduced so far. But at this point nothing has been introduced. So our principle tells us to introduce the set with no members (i.e., the empty set, \(\{\}\)). We call this ordinal &ldquo;\(0_o\)&rdquo;, and use it to represent the empty well-order type.</p>

<p>At the next stage of the process, our principle tells us to introduce the set of every ordinal that’s been introduced so far. But the only ordinal that has been introduced so far is \(0_o\). So our principle tells us to introduce the set \(\{0_o\}\) (i.e., the set \(\{\{\}\}\), read &ldquo;the set containing the empty set&rdquo;). We call this ordinal &ldquo;\(1_o\)&rdquo;, and use it to represent the well-order type that we had previously represented as &ldquo;|&rdquo;.</p>

<p>At the next stage of the process, our principle tells us to introduce the set of every ordinal that’s been introduced so far. What we’ve introduced so far is \(0_o\) and \(1_o\). So our principle tells us to introduce the set \(\{0_o,1_o\}\) (i.e., the set \(\{\{\},\{\{\}\}\}\)). We call this ordinal &ldquo;(2_o)&rdquo;, and use it to represent the well-order type that we had previously represented as &ldquo;||&rdquo;.</p>

<p>We then carry on this process, once for each natural number. That gives us the sets \(0_o,1_o,2_o,\ldots\). And we again apply the principle! As usual, the principle tells us to introduce the set of everything that’s been introduced so far. So we introduce the set \(\{0_o,1_o,2_o,\ldots\}\). We call this ordinal &ldquo;\(\omega\)&rdquo; (pronounced &ldquo;omega&rdquo;), and use it to represent the well-order type that we had previously represented as &ldquo;|||&hellip;&rdquo;.</p>

<p>And we carry on. At the next stage of the process, our principle tells us to introduce the set of everything that’s been introduced so far. So we introduce the set \(\{0_o,1_o,2_o,\ldots,\omega\}\). We call this ordinal \(\omega+1_o\) (pronounced &ldquo;omega plus one&rdquo;), and use it to represent the well-order type that we had previously represented as &ldquo;|||…|&rdquo;.</p>

<p>And so on.</p>

<br>

<h2 id="section_how">How the Ordinals are Ordered</h2>

<p>We already know that the well-order types are well-ordered. So, just as you expect, their representatives are also well-ordered. But they are well-ordered in an especially nice and transparent way. Let me explain.</p>

<p>As you can see, given the construction principle, every ordinal contains every ordinal that came before it. So if an ordinal is lower in the hierarchy than another, it is a member of that other.</p>

<p>That means that the ordinals are well-ordered by the set membership relation. That is:</p>

<blockquote>
<p>\(\alpha&lt;_o\beta\) iff \(\alpha\in\beta\)<br>
	where \(\alpha,\beta\) are ordinals, and \(&lt;_o\) is the ordering of the ordinals.</p>
</blockquote>

<p>Cool!</p>

<br>

<h2 id="section_which">Which Well-Order Type Does an Ordinal Represent?</h2>

<p>How do we know which well-order type a given ordinal represents? Since each ordinal is the set of its predecessors, and since any set of ordinals is well-ordered by \(&lt;_o\), each ordinal is itself well-ordered by \(&lt;_o\). The well-order type of <em>that ordering</em>, of the ordinal itself, is the well-order type that it represents!</p>

<p>For instance, \(\omega\) is the set \(\{0_o,1_o,2_o,\ldots\}\), and its elements are well-ordered as follows: \[0_o &lt;_o 1_o&lt;_o2_o&lt;_o\ldots\] So \(\omega\) represents the well-order type of that ordering &mdash; i.e.:
<center>
|||&hellip;
</center>
i.e., what we were calling an \(\omega\)-sequence. Now you know why.</p>

<br>

<h2 id="section_official">The Official Definition</h2>

<p>Here is the official definition of an ordinal. You don’t need to know it; this is just for the curious.</p>

<p>We have seen that, for every ordinal \(\alpha\), \(\alpha\) is well-ordered by \(\in\).</p>

<p>Another important property of ordinals is that they are <strong>set-transitive</strong>:<sup><a href="#fn:2" id="fnref:2" title="see footnote" class="footnote">2</a></sup> if \(\alpha\) is an ordinal, then every element of an element of \(\alpha\) is an element of \(\alpha\).</p>

<p>To see that all the ordinals are set-transitive, recall that every ordinal is built by pooling together the ordinals that were introduced at previous stages of the construction process. So suppose that \(\alpha\) and \(\beta\) are ordinals and that \(\beta \in \alpha\). If \(\beta\) has an element \(\gamma\), \(\gamma\) must be an ordinal which was introduced earlier than \(\beta\). But since \(\beta \in \alpha\), \(\beta\) must have been introduced earlier than \(\alpha\). So \(\gamma\) was introduced earlier than \(\alpha\). So \(\gamma \in \alpha\).</p>

<p>So: ordinals are set-transitive and well-ordered by \(\in\).</p>

<p>As it turns out, everything important about ordinals follows from these two properties. So set theorists define an ordinal as follows:</p>

<blockquote>
<p>An <strong>ordinal</strong> is a set that is set-transitive and well-ordered by \(\in\).</p>
</blockquote>

<p>(This assumes that we restrict our attention to what are called <strong>pure sets</strong>: sets such that all their members are sets, all the members of their members are sets, all the members of their members of their members are sets, and so forth.)</p>

<br>

</ul>

<h1 id="section_arithmetic">Ordinal Arithmetic</h1>

<p>The fact that the ordinals are themselves well-ordered means that they have a structure similar to that of the natural numbers. In fact, the natural numbers can be <em>identified</em> with the ordinals up to \(\omega\).</p>

<p>That being so, the arithmetical operations that work on the natural numbers can be extended, so that they apply across ordinals generally.</p>

<p>Let me show you how.</p>

<ul>

<h2 id="section_addition">Ordinal Addition</h2>

<p>We can define an addition operation for ordinals.</p>

<p>In general, the order type represented by \((\alpha+\beta)\) is the result of starting with the type of ordering that \(\alpha\) represents and appending the type of ordering that \(\beta\) represents at the end of it.</p>

<p>Consider, for example, the ordinal \((\omega+1_o)\). We get to it by starting with the type of ordering that \(\omega\) represents:</p>
<blockquote>
||||…
</blockquote>
and appending the type of ordering that \(1_o\) represents to the end. Since \(1_o\) represents this kind of ordering:</p>
<blockquote>
|
</blockquote>
what we get is this:
<blockquote>
||||…|
</blockquote></p>

<p>Now consider the ordinal \((\omega+\omega)\). It is the result of appending an ordering of the type that \(\omega\) represents:
<blockquote>
||||…
</blockquote>
to the end of itself. So what we get is this:
<blockquote>
||||…||||…
</blockquote></p>

<p>An important fact about ordinal addition is that, unlike normal addition, it is not commutative. For example: \[(1_o+\omega )\neq (\omega+1_o)\] For whereas \((\omega+1_o)\) represents an order type of the form
<blockquote>
||||…|
</blockquote>
\((1_o+\omega)\) represents an order type of the form
<blockquote>
||||…
</blockquote>
So, actually, \((1_o +\omega)=\omega\).</p>

<br>

<h2 id="section_multiplication">Ordinal Multiplication</h2>

<p>There is also a multiplication operation defined for ordinals.</p>

<p>In general, the order type represented by \((\alpha\times\beta)\) is the result of starting with the type of ordering that \(\beta\) represents and replacing each position in that order type with a full ordering of the type that \(\alpha\) represents.</p>

<p>Consider, for example, the ordinal \(\omega\times 2_o\). We get to it by starting with the type of ordering that \(2_o\) represents:
<blockquote>
||
</blockquote>
and replacing each position in that order type (here represented by &ldquo;|&rdquo;) with an ordering of the type that \(\omega\) represents; namely:</p>
<blockquote>
| | | | …
</blockquote>
So what we get is this:
<blockquote>
| | | | … | | | | …
</blockquote>
In other words: \((\omega\times 2_o) = (\omega+\omega)\).</p>

<p>Notice, however, that \((\omega\times 2_o)\neq(2_o\times\omega)\), since the result of starting with an ordering of the type that \(\omega\) represents:
<blockquote>
||||…
</blockquote>
and replacing each position &ldquo;|&rdquo; with an ordering of the type that \(2_o\) represents (namely &ldquo;||&rdquo;) is still:
<blockquote>
||||…
</blockquote>
In other words: \((2_o\times\omega)=\omega\).</p>

<p>As a final example, consider the ordinal \(\omega\times\omega\), which we get by starting with an ordering of the type that \(\omega\) represents:
<blockquote>
||||…
</blockquote>
and replacing each position &ldquo;|&rdquo; with an ordering of the type that \(\omega\) represents. When we get to ordinals like \((\omega\times\omega)\) it starts becoming difficult to draw perspicuous diagrams. I tried to do so earlier, using this:
<blockquote>
(||||…||||…||||…||||…)…
</blockquote></p>

</ul>

<br>

<p>I won’t show you how to do it here, but we can define an ordinal version of exponentiation, too. And we can go further than that! We&rsquo;ll talk more about this towards the end.</p>

<br>

<h1 id="section_build">How to Build Large Sets Using Ordinals</h1>

<p>What do well-orderings have to do with big sets? Well, you can think of each well-ordering as a <em>blueprint</em> for building a very large set. To explain how to get from the well-ordering to the set, I’ll first need to tell you about the distinction between successor ordinals and limit ordinals.</p>

<p>A <strong>successor ordinal</strong> is an ordinal with an immediate predecessor. In other words, it is an ordinal \(\alpha\) such that \(\alpha = \beta + 1_o\) for some \(\beta\). For instance: \(7_o\) is a successor ordinal, since its immediate predecessor is \(6_o\). And so is \(\omega + \omega + 37_o\), since its immediate predecessor is \(\omega + \omega + 36_o\) .</p>

<p>A <strong>limit ordinal</strong> is an ordinal with no immediate predecessor. In other words, it is an ordinal \(\alpha\) such that \(\beta + 1_o &lt;_o \alpha\) for any \(\beta &lt;_o \alpha\). For instance: \(\omega\) is a limit ordinal, since it has no immediate predecessor. And so is \(\omega \times \omega\). And so is \(0_o\).</p>

<p>Okay, now here’s how you get from an ordinal \(\alpha\) to a big set, \(S_\alpha\)</p>

<p>The first step is to consider the sequence of ordinals smaller than or equal to \(\alpha\). Suppose, for example, that \(\alpha = (\omega + \omega)\). Then the sequence of ordinals we shall consider is:\[\langle 0_o, 1_o, 2_o, \ldots, \omega, (\omega+1_o), \ldots, (\omega + \omega) \rangle\]</p>

<p>Next, we determine whether each member of the sequence is a limit ordinal or a successor ordinal. Below, I have marked out limit ordinals by underlining them: \[\langle \underline{0_o}, 1_o, 2_o, \ldots, \underline{\omega}, (\omega+1_o), \ldots, \underline{(\omega + \omega)} \rangle\]</p>

<p>Now imagine placing an empty box on top of each element of the sequence: \[\langle \underbrace{[\quad]}_{\underline{0_o}}, \underbrace{[\quad]}_{1_o}, \underbrace{[\quad]}_{2_o}, \ldots, \underbrace{[\quad]}_{\underline{\omega}}, \underbrace{[\quad]}_{\omega+1_o}, \ldots, \underbrace{[\quad]}_{\underline{\omega + \omega}} \rangle\] and filling the boxes in accordance with the following recipe:
<ul>
<li>Fill the box corresponding to \(0_o\) with the set of natural numbers, \(\mathbb{N}\).</li>
<li>Fill the box corresponding to a successor ordinal with the result of applying the power set operation to whatever is in the preceding box.</li>
<li>Fill the box corresponding to a limit ordinal (other than \(0_o\)) with the union of everything that&#8217;s been placed in a box so far.</li>
</ul></p>

<p>In our example, this yields the following result: \[\left\langle \underbrace{[\mathbb{N}]}_{\underline{0_o}}, \underbrace{[\mathcal{P}(\mathbb{N})]}_{1_o}, \underbrace{[\mathcal{P}(\mathcal{P}(\mathbb{N}))]}_{2_o}, \ldots, \underbrace{\left[\bigcup_{n \in \mathbb{N}} \mathcal{P}^n(\mathbb{N})\right]}_{\underline{\omega}}, \underbrace{\left[\mathcal{P}\left(\bigcup_{n \in \mathbb{N}} \mathcal{P}^n(\mathbb{N})\right)\right]}_{\omega+1_o}, \ldots, \underbrace{\left[\bigcup_{m \in \mathbb{N}} \mathcal{P}^m\left(\bigcup_{n \in \mathbb{N}} \mathcal{P}^n(\mathbb{N})\right)\right]}_{\underline{\omega + \omega}} \right\rangle\]</p>

<p>Once our sequences of boxes has been filled out, it is easy to define our target set \(S_\alpha\). \(S_\alpha\) is just the set contained in the box at the very end of our sequence. So, in our example,
\[S_\alpha = S_{\omega+\omega} = \bigcup_{m \in \mathbb{N}} \mathcal{P}^m\left(\bigcup_{n \in \mathbb{N}} \mathcal{P}^n(\mathbb{N})\right)\]</p>

<p>Here is a longer list of examples:
	<center>
	<table style="width:50%">
		<tr> <th style="text-align:left"> Ordinal \(\alpha\):</th> <th style="text-align:left">Set \(S_\alpha\) generated from \(\alpha\):</th> </tr>
		<tr> <td>\(0_o\)</td> <td>\(\mathbb{N}\)</td> </tr>
		<tr> <td>\(1_o\)</td> <td>\(\mathcal{P}(\mathbb{N})\)</td> </tr>
		<tr> <td>\(2_o\)</td> <td>\(\mathcal{P}^2(\mathbb{N})\)</td> </tr>
		<tr> <td>\(\vdots\)</td> <td>\(\vdots\)</td> </tr>
		<tr> <td>\(\omega\)</td> <td>\(\bigcup_{n \in \mathbb{N}} \mathcal{P}^n(\mathbb{N})\)</td> </tr>
		<tr> <td>\(\omega + 1_o\)</td> <td>\(\mathcal{P}\left(\bigcup_{n \in \mathbb{N}} \mathcal{P}^n(\mathbb{N})\right)\)</td> </tr>
		<tr> <td>\(\omega + 2_o\)</td> <td>\(\mathcal{P}^2\left(\bigcup_{n \in \mathbb{N}} \mathcal{P}^n(\mathbb{N})\right)\)</td> </tr>
		<tr> <td>\(\vdots\)</td> <td>\(\vdots\)</td> </tr>
		<tr> <td>\(\omega + \omega\)</td> <td>\(\bigcup_{m \in \mathbb{N}} \mathcal{P}^m\left(\bigcup_{n \in \mathbb{N}} \mathcal{P}^n(\mathbb{N})\right)\)</td> </tr>
		<tr> <td>\((\omega + \omega) + 1_o\)</td> <td>\(\mathcal{P}\left(\bigcup_{m \in \mathbb{N}} \mathcal{P}^m\left(\bigcup_{n \in \mathbb{N}} \mathcal{P}^n(\mathbb{N})\right)\right)\)</td> </tr>
		<tr> <td>\(\vdots\)</td> <td>\(\vdots\)</td> </tr>
	</table>
	</center>
</p>

<br>

<h1 id="section_senses">Two Different Senses of “\(&lt;\)”</h1>

<p>The nice thing about the above procedure for building \(S_\alpha\) on the basis of \(\alpha\) is that it is absolutely general: it can be applied to any ordinal \(\alpha\). And the procedure is guaranteed to deliver bigger and bigger outputs as you chooses ordinals that are farther and farther along in the hierarchy of ordinals. That is: the set \(S_{\beta}\) will always have more elements than the set \(S_{\alpha}\), if \(\alpha &lt; _o \beta\).</p>

<p>Another way of putting this:
<blockquote>
If \(\alpha &lt;_o \beta\), then \(|S_\alpha| &lt; |S_\beta|\).
</blockquote></p>

<p>It is important to keep in mind, though, that &ldquo;\(&lt;_o\)&rdquo; and &ldquo;\(&lt;\)&rdquo;, in the above statement, are different relations.</p>

<p>“\(&lt;_o\)” is used to describe the standard way of ordering the ordinals. As we said above, when \(\alpha\) and \(\beta\) are ordinals, \(\alpha &lt;_o \beta\) is defined as \(\alpha \in \beta\).</p>

<p>“\(&lt;\)” is used to say that one set has a bigger cardinality than the other. As we noted in Topic 3, when \(A\) and \(B\) are arbitrary sets, \(|A| &lt; |B|\) is defined as \(|A| \leq |B|\) and \(|A| \neq |B|\) &mdash; i.e., there is an injection from \(A\) to \(B\), but no bijection from \(A\) to \(B\).</p>

<p>Thus, whereas \(\alpha &lt;_o \beta\) tells us that \(\alpha\) comes earlier than \(\beta\) on the standard way of ordering ordinals, \(|S_\alpha| &lt; |S_\beta|\) tells us that \(S_\beta\) has more elements than \(S_\alpha\).</p>

<p>Consider, for example, the ordinals \(\omega\) and \(\omega + \omega\). We know that \(\omega &lt;_o \omega + \omega\). What that means is that \(\omega\) comes earlier than \(\omega + \omega\) on the standard way of ordering ordinals. It does not mean that \(\omega\) has more members than \(\omega+\omega\). In fact, each of these two sets have precisely as many members as there are natural numbers: \[|\omega| = |\omega + \omega| = |\mathbb{N}|\]</p>

<p>In contrast, \(S_{\omega + \omega}\) is <em>much</em> bigger than \(S_\omega\), and they are both much bigger than the set of the natural numbers: \[|\mathbb{N}| &lt; |S_{\omega}| &lt; |S_{\omega + \omega}|\]</p>

<br>

<h1 id="section_far">How Far Can You Go?</h1>

<ul>

<h2 id="section_start">A Good Start</h2>

<p>Now we have a very powerful way to build larger and larger sets: we name larger and larger ordinals, and use them as blueprints to build larger and larger sets. Let’s start with \(\omega\), and, hence, \(S_\omega\).</p>

<p>To give you a sense of how big we’re talking, bear in mind that \(S_{2_o}\) is to the set of the reals as the set of the reals is to the set of the natural numbers. And that is just <em>two steps</em> past the natural numbers. So \(S_\omega\) is unfathomably big. The relationship between \(S_\omega\) and the set of the natural numbers is something like the relationship between the natural numbers and 1.</p>

<p>But we can already do so much better than that. We know about ordinal arithmetic. The whole point of ordinal arithmetic is that it enables us to name really large ordinals.</p>

<p>Consider \(S_{\omega\times 2_o}\). That’s as many steps past \(S_\omega\) as \(S_\omega\) is past the natural numbers. The natural numbers are but a distant, miniscule memory, when you’re as big as \(S_{\omega\times 2_o}\).</p>

<p>But that’s nothing! How about \(S_{\omega\times\omega}\)? \(S_{\omega\times\omega}\) is to \(S_\omega\) as, again, the natural numbers are to 1.</p>

<p>We want to go as big as we can. How about something like this: \[\underbrace{\omega \times \omega \times \ldots \times \omega}_{10^{100} \text{ times}}\]</p>

<p>The set you build out of that ordinal blows out of the water anything we’ve discussed so far.</p>

<p>We’re just getting started. If we want, we can define an exponentiation function on ordinals; it is an iteration of mutltiplication for ordinals, as you would expect.<sup><a href="#fn:3" id="fnref:3" title="see footnote" class="footnote">3</a></sup> So consider \(\omega^\omega\). The picture in the top right of this page is a valiant effort to draw the well-ordering represented by \(\omega^\omega\) (stare at it a while and you’ll get the idea). \(S_{\omega^\omega}\) is vastly, vastly, vastly larger than the set named above, with all the multiplication.</p>

<p>We can easily go bigger: consider this ordinal:\[\omega^{\omega^{\omega^{\omega}}}\] and hence: \(S_{\omega^{\omega^{\omega^{\omega}}}}\). That’s a much, much bigger size of infinity than anything we’ve talked about so far.</p>

<br>

<h2 id="section_nonrecursive">Non-Recursive Orderings</h2>

<p>We can, of course, go way past \(S_{\omega^{\omega^{\omega^{\omega}}}}\). When we get sick of exponentiation, we can start using <a href="https://en.wikipedia.org/wiki/Tetration">tetration</a>, which is sometimes written like this: \[^\beta\alpha\] What that means is: \[\alpha^{\alpha^{\alpha^{\ldots}}}\] …with \(\beta\) many \(\alpha\)s in the exponentiation tower.</p>

<p>Then you can make ordinals like this: \[^{^{\omega}\omega}\omega\] and use that to make a truly ginormous set.</p>

<p>And then you can define <a href="https://en.wikipedia.org/wiki/Pentation">pentation</a>, and hexation, and more and more <a href="https://en.wikipedia.org/wiki/Hyperoperation">hyperoperations</a>, as they are called.</p> 

<p>When you get sick of doing that, you can define something like this:
<ul>
<li> let \(\alpha \uparrow^1\beta\) equal \(\alpha^\beta\)</li>
<li> let \(\alpha\uparrow^2\beta\) equal \(^\beta\alpha\)</li>
<li> and so on</li>
</ul>
…and make ordinals like this: \[\omega\uparrow^\omega\omega\]
…and use that as a blueprint to make this set: \[S_{\omega\uparrow^\omega\omega}\]
…which is untold vast eternities bigger than anything discussed so far.</p>

<p>But we want bigger!</p>

<p>As we’ve been considering more and more crazy orderings, they have been getting more and more complicated. But something all of these orderings so far have in common is that they are all <em>recursive</em>. What that means, basically,<sup><a href="#fn:4" id="fnref:4" title="see footnote" class="footnote">4</a></sup> is that you could write a (perhaps very long) computer program that could do the following: you input two elements of the ordering, and it outputs which one is bigger.</p>

<p>Now, it turns out that there are well-orderings that are <em>not</em> recursive — they are so complicated that no computer program could possibly, even in principle, be written that can always tell you which of any two elements comes first in that ordering. The ordinal that represents the smallest non-recursive well-ordering is called “\(\rho\)” (usually written in English as “rho”; it’s pronounced like “row”). \(S_\rho\) makes everything thus far, including \(S_{\omega\uparrow^\omega\omega}\) look absolutely miniscule. Not to mention \(S_{\rho\uparrow^\rho \rho}\).</p>

<br>

<h2 id="section_uncountable">Ordinals with Uncountable Cardinalities</h2>

<p>We’ve gotten pretty big. But we can go bigger.</p>

<p>We&rsquo;ve been building sets with way bigger cardinalities than the natural numbers. But all of our blueprints &mdash; i.e., all of the ordinals we are using to build these big sets &mdash; have, so far, had the cardinality of the natural numbers. Even \(\rho\uparrow^\rho \rho\), as unimaginably wild as it is, is an ordinal with the cardinality of the natural numbers that represents a really crazy way of ordering natural-numbers-many things.</p>

<p>If you want to go <em>really</em> big, you need to start talking about ordinals with bigger cardinalities.</p>

<p>The <strong>well-ordering theorem</strong> says that every set can be well-ordered. The theorem in full generality is, in fact, equivalent to our old friend the Axiom of Choice. If it is true, then, way beyond any of the well-orderings we&rsquo;ve been discussing, is the first well-ordering of a set with the cardinality of the real numbers. Hence, there is a first ordinal with the cardinality of the real numbers.</p>

<p>Ordinals that are the first to have their cardinality are called “initial ordinals”. Sometimes the hebrew symbol “\(\beth\)” (pronounced “beth”) is used to refer to these initial ordinals.<sup><a href="#fn:5" id="fnref:5" title="see footnote" class="footnote">5</a></sup></p>

<p>The \(\beth\)s are subscripted, to indicate their order. \(\beth_0\) is the first infinite initial ordinal — i.e., \(\omega\), the first ordinal with the cardinality of the natural numbers.</p>

<p>If the well-ordering theorem is true, then there is an ordinal \(\beth_1\), which is the first ordinal with the cardinality of the real numbers.</p>

<p>Incidentally, the \(\beth\)s are also used to represent a particular cardinality, and are themselves sometimes called “cardinals”. So, for instance, the cardinality of the real numbers can be written as “\(\beth_1\)”, and the following sentence is true \[|\mathbb{R}|=\beth_1\]</p>

<p>Now, \(S_{\beth_1}\) — the set you get by using \(\beth_1\) as your blueprint — is utterly gargantuan; everything we’ve talked about until now is the merest speck upon a speck compared to \(S_{\beth_1}\).</p>

<p>But again, we can do much, much better. We have a bootstrapping procedure in place: we can use the ordinals to build sets with really huge cardinalities, and then use those cardinalities to specify enormous ordinals, which we can use as enormous blueprints to build even more gargantuan sets, which give us more gargantuan ordinals, which…and so on.</p>

<p>So there is a \(\beth_\omega\), and a \(S_{\beth_\omega}\). It goes without saying that that is way way bigger than anything so far. And \(|S_{\beth_\omega}|=\beth_{\beth_\omega}\). So there is a \(S_{\beth_{\beth_\omega}}\). And \(|S_{\beth_{\beth_\omega}}|=\beth_{\beth_{\beth_\omega}}\). And so on. Each time you go up in this series, everything that comes before is made insignficant in size, by comparison.</p>

<br>

<h2 id="section_cthulhu">Cthulhu</h2>

<p>There is a limit to the sequence \[\langle\beth_\omega, \beth_{\beth_\omega}, \beth_{\beth_{\beth_\omega}}, \ldots\rangle\] That limit is an ordinal that has <em>the same cardinality</em> as the set you build out of it. That horrific monster set is a dark, infernal universe in which everything we have talked about until now is an atom.</p>

<p>This is the point where I, personally, lose my grip on what is going on. But I am told, by people who know more about this, that that is just the beginning. It gets much, much bigger.</p>

</ul>

<div class="footnotes">
<hr />
<ol>

<li id="fn:1">
<p>Well, actually, sometimes the natural numbers are themselves identified with certain sets. In fact, they are sometiems identified with certain ordinals! You'll see the idea later. But don&rsquo;t let this confuse you; for now, just think of \(\mathcal{P}^0(\mathbb{N})\) as containing nothing but good old fashioned numbers.<a href="#fnref:1" title="return to article" class="reversefootnote">&#160;&#8617;</a></p>
</li>

<li id="fn:2">
<p>I am using the phrase &ldquo;set-transitivity&rdquo; to distinguish this property, which is of sets, from what I earlier called &ldquo;transitivty&ldquo;, which is a quite different property of orderings. But just so you know, in case you read other literature on this topic: both of these properties are typically called &ldquo;transitivty&ldquo;, and what I am calling a &ldquo;set-transitive set&rdquo; is typically called a &ldquo;transitive set&rdquo;.<a href="#fnref:2" title="return to article" class="reversefootnote">&#160;&#8617;</a></p>
</li>

<li id="fn:3">
<p>To define ordinal exponentiation properly, we&rsquo;d have to define ordinal multiplication and ordinal addition a little more formally than we have here; ask me or your TAs if you&rsquo;re interested in how.<a href="#fnref:3" title="return to article" class="reversefootnote">&#160;&#8617;</a></p>
</li>


<li id="fn:4">
<p>We will get more precise about what exactly that means when we talk about <em>computability</em>, later in this course.<a href="#fnref:4" title="return to article" class="reversefootnote">&#160;&#8617;</a></p>
</li>

<li id="fn:5">
<p>Actually, the \(\beth\)s, by definition, are initial ordinals that have cardinalities of the kind we&rsquo;re talking about: you get to them by starting with \(\mathbb{N}\), and then power-setting and unioning. It is an open question whether these are <em>all</em> the initial ordinals. The thesis that the \(\beth\)s <em>are</em> all the initial ordinals is called the <strong>generalised continuum hypothesis</strong>, and it is <em>the</em> outstanding question of set theory.</p>

<p>The generalised continuum hypothesis is known to be independent of the standard axioms of set theory. What that means for the truth or falsity of the hypothesis is a complicated question, much debated in philosophy of mathematics.</p>

<p>There is another way of listing intitial ordinals using the hebrew symbol &ldquo;\(\aleph\)&rdquo;, written as &ldquo;aleph&rdquo; in English. \(\aleph_0\) is our old friend \(\omega\), \(\aleph_1\) is the next biggest initial ordinal, whatever that is. Maybe it&rsquo;s \(\beth_1\), maybe not. Another way of putting the generalised continuum hypothesis is this: for all \(\alpha\), \(\aleph_\alpha=\beth_\alpha\).<a href="#fnref:5" title="return to article" class="reversefootnote">&#160;&#8617;</a></p></p>
</li>

</ol>
</div>


</body>
</html>