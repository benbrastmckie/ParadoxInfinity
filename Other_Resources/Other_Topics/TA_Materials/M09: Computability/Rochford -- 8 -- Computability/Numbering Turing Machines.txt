#Numbering Turing Machines

We know that there are countably many Turing Machines. So we know that there is a way of assigning a different natural number to each Turing Machine.

We can, in fact, *describe* a particular way of assigning numbers to Turing Machines. What’s more, we can describe a way of doing this in enough detail that two things are true:
	a) were you to give me the specifications of a random Turing Machine, I could tell you which number is assigned to it, and, more importantly,
	b) if you give me a number, I can tell you if that number corresponds to a Turing Machine, and, if so, which.
	In short, we can describe a way of *coding* Turing Machines as natural numbers. Our code will allow you to recover the Turing Machine from a given natural number.
	This is an important fact that we will use in proofs to come. Let’s pick a particular coding scheme and look at the details, to get clear on how it can be done.

##Two-Symbol Machines

Before describing the coding scheme in detail, it will be useful to make a simplifying assumption. We will focus our attention on ‘two-symbol’ Turing Machines, that is, on Turing Machines in which the tape is only allowed to contain ones and blanks. 

As it turns out, this restriction is no restriction at all, because every function that can be computed on a many-symbol Turing Machine can also be computed on a two-symbol Turing Machine. You’ll prove this on your problem set.

##Our Scheme
 
 Recall that each command line in a Turing Machine is a five-tuple of symbols:

<current state> <current symbol> <new symbol> <direction> <new state>

By making a few simple substitutions we can code such a sequence as a sequence of five natural numbers:

 * <current state> and <new state> are natural numbers already, so we can leave them as they are.
 * <current symbol> and  <new symbol> are either “1” or “_“. (Remember that we are working with two-symbol Turing machines.) So all we need to do is substitute “0” for “_“.
 * <direction> is “l”, “r” or “*”, which we can substitute ‘0’, ‘1’ and ‘2’ for, respectively. 
So, for example, the command line:

0 _ 1 r 1

becomes the following sequence of natural numbers:

0 0 1 1 1

Now consider a Turing Machine’s entire program. We can code it as a sequence of natural numbers in two steps: (1) code each line of the program as a sequence of five numbers, and (2) write out each of the resulting five-number sequences, one after the other. So, for instance, the program:

0 _ 1 * 0

0 1 1 r 1

gets coded as:

0 0 1 2 0 0 1 1 1 1

What we have succeeded in doing so far is represent a Turing Machine as a sequence of natural numbers, but remember that our objective is to code a Turing Machine as a single natural number. So what we need now is a method for coding each sequence of natural numbers as a unique natural number.

There are many ways of doing this. But the method we will consider here is due to Kurt Gödel, about whom you’ll be hearing more soon. It works like this:

Code the sequence \(n_1, n_2, \ldots, n_k\) as the number: \[p_{1}^{n_{1}+1}\times p_2^{n_2+1}\times\ldots\times p_k^{n_k+1}\] where \(p_1\ldots p_k\) are the first \(k\) prime numbers.

For instance, the sequence 0 0 1 1 1 gets coded as: \[2^{0+1}\times 3^{0+1}\times 5^{1+1}\times 7^{1+1}\times 11^{1+1} = 2\times 3\times 25\times 49\times 121 = 889,350\]

To verify that this gives us what we want, imagine that I have a particular two-state Turing Machine, and that I want to use a natural number to tell you which one it is. I proceed in two stages. First I represent the Turing Machine as a sequence of natural numbers. I then use Gödel’s method to code the sequence as a single natural number, and send you that number.

When you receive the number, will you be able to figure out which Turing Machine I started with? Yes! For recall the Fundamental Theorem of Arithmetic, which states that every positive integer greater than 2 has a unique decomposition into primes. This means if you factor the number I gave you into primes and look at the exponents, you’ll be able to recover the sequence of numbers I used in my coding. And once you have the sequence, you’ll have no trouble recovering the Turing Machine I started with. 

So we’re done: we’ve found a way to code Turing Machines as natural numbers.
