




\documentclass[12pt,a4paper]{article}


%Spacing Packages
\usepackage{fullpage}
\usepackage{a4wide}
%\usepackage{setspace}
%\usepackage{endnotes} \let\footnote=\endnote %Remember to update below

% Bibliography Packages
%\usepackage{linquiry}
\usepackage{natbib}

\usepackage{enumerate}

%Other Packages
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{euscript}
%\usepackage{latexsym}
%\usepackage{amsfonts}

\usepackage[lf]{venturis} %% lf option gives lining figures as default; 
			  %% remove option to get oldstyle figures as default
\usepackage[T1]{fontenc}



%Diagram packages
%\usepackage{bar}
%\usepackage{curves}
%\usepackage{pst-plot}

%Tree packages
%\usepackage{ecltree}
%\usepackage{eclbip}
%\usepackage{eepic}
%\usepackage{epic}


\begin{document}
\begin{center} {\large 24.118x -- Paradox and Infinity \\ \vspace{1mm}}
 {\large Problem Set 8: Answer sheet \\ \vspace{1mm}}
 
\end{center}
\vspace{3mm}


\subsection*{Problems:}


\begin{enumerate}
\item The first thing to do is to find an injection $f$ from three-symbol tapes to two-symbol tapes. It needs to be an injection so that you don't lose any information when you go from one to the other.

This is one such injection: let $f(t)$ be the two-symbol tape you get by replacing each blank ``$\_$'' on $t$ by a double-blank ``$\_\_$''; replacing each ``$0$'' on $t$ by ``$1\_$''; replacing each ``$1$'' on $t$ by ``$11$''.

How do we know $f$ is an injection? You can prove it by mathematical induction (though you didn't need to do this to get full marks for this problem). Here is the outline of how to do it:
\begin{itemize}
\item Base Case: consider the set $S_0$ all three symbol tapes such that the sub-string that starts with the first non-blank symbol and ends with the last non-blank symbol is 0 symbols long. Trivially, every member of this set gets assigned a different two symbol tape by $f$ --- there is only one tape in $S_0$, the completely blank tape, and it gets transformed into a completely blank tape.
\item Inductive Step: consider the set $S_n$ of all two-symbol-plus-blank tapes such that the sub-string that starts with the first non-blank symbol and ends with the last non-blank symbol is $n$ symbols long. Suppose that every member $S_k$ is transformed into a different one-symbol-plus-blanks tape, for all $k\le n$. Prove from this assumption that every member of $S_{n+1}$ is transformed into a different two-symbol tape.
\end{itemize}

Now, how do you transform the Turing Machine program that worked on your three-symbol tape into a Turing Machine that will work on your two-symbol tape? There are more efficient ways to do this for particular Turing Machines, but here is a recipe that will always work. I won't describe it in full details (and you didn't have to either, to get full marks); I'll just say enough to give you the idea.

The idea is, we replace each line of the original code with a little sub-routine, that has the same effect as that line of code, when that effect is translated into two-symbol language (as opposed to the original three-symbol language). This takes many lines of code, rather than one, because each time we read a cell in the old language we need to read \emph{two} cells in the new language; and each time we change a cell in the old language we need to (possibly) change \emph{two} cells in the new language.

So, for example: suppose our first line of code in the original, three-symbol Turing Machine program, said something like:$$0 \ 0 \ 1 \ l \ 1$$

We'd need to replace that with something like this: $$0 \ 1 \ 1 \ r \ 1$$
$$1 \ \_ \ 1 \  l \ 2$$
$$2 \ 1 \ 1 \ l \ 3$$
$$3 \ \_ \ \_ \ l \ 4$$
$$3 \ 1 \ 1 \ l \ 4$$ 

Where the old code read a ``$0$'' and replaced it with a ``$1$'', this new code reads a ``1'' followed by a blank, and then changes the blank into a ``$1$'' --- that is, it transforms ``$1\_$'' into ``$11$''.

After doing that, this code then moves to the left, the left again over the ``$1$'' it started on, then a further step left, so that it is at the beginning of the two cells before the cell it started on. That is the equivalent of moving left one cell, in the new language.

Note that this sub-routine ends in state ``4'', which means that we'll have to use ``4'' as the name of the first state in the subroutine we write to replace the old code for state ``1''.

\item 
\begin{enumerate}
\item We talked about this in lecture. Your answer doesn't have to be along these lines, but here is a schema for code that would do the trick:\newline

$0 \ \_ \ 1 \ r \ 1$ \newline
$1 \ \_ \ 1 \ r \ 2$ \newline
\ldots \newline
$(k-1) \ \_ \ 1 \ l \ k$ \newline
$k \ 1 \ 1 \ l \ k$ \newline
$k \ \_ \ \_ \ r \ \texttt{halt}$\newline

This machine has $k+1$ states.

\item The solution below particularly efficient, in terms of number of states. See if you can follow it. (Again, this didn't have to be your solution, as long as it worked.)\newline

$0 \ 1 \ X \ l \ 1$ ; search for ``1''s and replace by ``X'' \newline
$0 \ X \ X \ r \ 0$ \newline
$0 \ \_ \ \_ \ l \ 2$ ; enter cleanup stage \newline
$1 \ \_ \ X \ r \ 0$ ; write down new ``X'' and go back to search for 1s \newline
$1 \ X \ X \ l \ 1$ \newline
$2 \ X \ 1 \ l \ 2$ ; cleanup \newline
$2 \ \_ \ \_ \ r \ \texttt{halt}$\newline

This machine has three states. It is worth noting that it uses the additional symbol ``$X$'' and is therefore a three-symbol machine. If you wanted to build a two-symbol machine, you would need additional states.

\item This is the most straightforward solution:\newline

$0 1 1 r 0$ \newline
$0 \_ 1 l 1$ \newline
$1 1 1 l 1$ \newline
$1 \_ \_ r \texttt{halt}$\newline

This machine has two states.

\item

$$|M^E| = a_k + b + c + d = (k+1) + 3 + c + 2 = k+ c + 6$$

\end{enumerate}

\item 
\begin{enumerate}
\item Lots of examples; here's mine. Let $f$ be the identify function. In order to compute $f(n)$ a Turing Machine must print $n$ ones as output, and therefore use at least $n$ many cells on the tape. So for arbtirary $m$, one can let $k = m+1$.

\item No, there is no such $k$, if $f(n)$ is indeed Turing-computable. There can be no such $k$ because $M$ can only compute $f(n)$ if it halts after a finite number of steps for each $n$.

\end{enumerate}

\item Again, we talked about this in class; here's a way to do it. For every $n$, there is a finite number of Turing Machines with $n$ states or less. So here's a way to compute $BB(n)$ using our oracle-machine: it tests whether a particular Turing Machine with $n$ states or less halts or not, using the oracle. If it doesn't halt, it moves on to the next Turing Machine; if it does halt, it simulates that Turing Machine, the way a Universal Turing Machine does, and records the output of that Machine. It does that for each Turing Machine with $n$ states or less. It then finds the largest output of all of them, and deletes everything else on the tape, leaving that output as its own output.

\item 
\begin{enumerate}

\item There is something wrong with that argument. The problem is in the presupposition that $M^O$ is a Turing Machine. It is not. Turing Machines, as defined in this class and everywhere else, do not have a halting operations. We could equip a Turing Machine with a halting operation, but the result is \emph{not} a Turing Machine.

Not being a Turing Machine, $M^O$ is not the $n^\text{th}$ Turing Machine, so there is no problem in $M^O$ doing whatever, when given $n$ or anything else as input.

Now, let us call the result of equipping a Turing Machine with a halting operation an ``oracle machine''. An let $H_1(n,m)$ be the function that equals $1$ if the $n\text{th}$ oracle machine halts when given input $m$, and $0$ otherwise. An argument very like the one in this question shows that $H_1(n,m)$ is not oracle-machine-computable (and obviously not Turing-computable either, as anything that is Turing-computable is oracle-computable).

You can add a ``super-oracle'', which solves the oracle-machine Halting problem, to an oracle machine, and get a super-oracle-machine. But then you can show that $H_2(n,m)$, the halting function for super-oracle-machines, is not super-oracle-computable.

This can keep going forever. There is an $H_\omega(n,m)$, and beyond\ldots

\item Here is a way to do it, though it's kind of cheating. Write a program on the tape for computing $\uparrow^1$. That's not so hard -- that just exponentiation. Then use that to write a program for calculating $\uparrow^2$; it will involve the $\uparrow^1$ program as a subroutine, and iterating the right number of times. The use that to write a program for $\uparrow^3$. The process of using the code for $\uparrow^n$ to write a program that computes $\uparrow^{n+1}$ is itself computable, clearly. Iterate that until you get to $\uparrow^k$. Then universal-turing machine that code on the tape to calculate $k\uparrow^k k$.

\end{enumerate} 

\end{enumerate}


\end{document}
