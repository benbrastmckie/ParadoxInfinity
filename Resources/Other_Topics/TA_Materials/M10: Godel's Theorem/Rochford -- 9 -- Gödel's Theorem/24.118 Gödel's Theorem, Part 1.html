<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"/>
	<title>24.118: Gödel’s Theorem, Part 1</title>
	<meta name="author" content="Damien Rochford (based on notes by Agustín Rayo)"/>
	<link rel="stylesheet" type="text/css" href="philosstylegodel.css">
	<script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
</head>
<body>
<em class="philosophysmall"> 24.118:</em> <em
 class="titlesmall">Gödel&rsquo;s Theorem, Part 1</em> <img style="padding-right:60px" src="http://artinsect.org/wp-content/uploads/2014/08/kurt-godel.jpg" alt=
"A portrait of Kurt Gödel, but with things looking crazy. Kind of Warhol-esque." width="40%" align="right">

<ul>
<li><a href="#section_intro">Gödel’s Theorem</a>

<ul>
<li><a href="#section_stated">First Incompleteness Theorem Stated</a></li>
<li><a href="#section_importance">Philosophical Importance</a></li>
</ul></li>
<li><a href="#section_language">The Language of Arithmetic</a>

<ul>
<li><a href="#section_l">Introducing \(\mathcal{L}\)</a></li>
<li><a href="#section_symbols">Symbols in \(\mathcal{L}\)</a>

<ul>
<li><a href="#section_arithmetical">Arithmetical Terms</a></li>
<li><a href="#section_identity">Identity</a></li>
<li><a href="#section_logical">Logical Operators</a></li>
<li><a href="#section_variables">Variables and Quantifiers</a></li>
<li><a href="#section_substitution">Formulas, Sentences, Binding and Substitution</a></li>
</ul></li>
<li><a href="#section_mighty">Simple Yet Mighty</a>

<ul>
<li><a href="#section_defining">Defining New Vocabulary in \(\mathcal{L}\)</a></li>
</ul></li>
</ul></li>
<li><a href="#section_machines">Talking About Turing Machines in \(\mathcal{L}\)</a>

<ul>
<li><a href="#section_sequences">Sequences</a>

<ul>
<li><a href="#section_pairs">Pairs</a></li>
<li><a href="#section_onemore">One More Useful Formula</a></li>
</ul></li>
<li><a href="#section_tms">Turing Machines</a>

<ul>
<li><a href="#section_command">Command Lines</a></li>
<li><a href="#section_programs">Programs</a></li>
<li><a href="#section_tape">The Tape</a></li>
</ul></li>
<li><a href="#section_running">Running the Machine</a>

<ul>
<li><a href="#section_moments">Turing Machine Moments</a></li>
<li><a href="#section_moments">Special Moments</a></li>
<li><a href="#section_step">Step By Step</a></li>
<li><a href="#section_validate">Validate</a></li>
</ul></li>
</ul></li>
<li><a href="#section_proved">Gödel’s First Incompleteness Theorem Proved</a>

<ul>
<li><a href="#section_using">Using \(\mathcal{L}\) to talk about \(\mathcal{L}\)</a></li>
<li><a href="#section_overview">Overview of the Proof</a></li>
<li><a href="#section_sentence">The Gödel Sentence</a>

<ul>
<li><a href="#section_coded">Substitution Coded</a></li>
<li><a href="#section_quine">The Quine Sentence</a></li>
<li><a href="#section_completed">The Proof Completed</a></li>
</ul></li>
</ul></li>
</ul>

<h1 id="section_intro">Gödel’s Theorem</h1>

<p>Gödel’s Incompleteness Theorems are the most important results in all of logic. They are extraordinarily beautiful. They also have significant philosophical and mathematical implications. They were first proved by Austrian logician <a href="https://en.wikipedia.org/wiki/Kurt_G%C3%B6del">Kurt Gödel</a>, in 1931. He&rsquo;s watching you from the top right corner of this page, and also from the transcendental plane of logic.</p>

<ul>

<h2 id="section_stated">First Incompleteness Theorem Stated</h2>

<p>We will mostly discuss Gödel’s First Incompleteness Theorem; we will say some things about Gödel’s Second Incompleteness Theorem towards the end of this unit.</p>

<p>There are many equivalent ways of stating Gödel’s First Incompleteness Theorem. In these notes will be working with this formulation:</p>

<blockquote>
<p><strong>Gödel’s First Incompleteness Theorem (Validating Turing Machine Version)</strong>
It is impossible to construct a Turing Machine that outputs a “\(1\)” if and only if it is given a true sentence of arithmetic as input.</p>
</blockquote>

(In lecture, Matt gave a slightly different but equivalent version, also involving Turing Machines.)

<p>Another way of putting this: it is impossible to construct a Turing Machine that <strong>validates</strong> all and only the true sentences of \(\mathcal{L}\).</p>

<p>You can think of this formulation of the the theorem as saying that mathematical truth is too complex to be captured in the programming of a Turing Machine, and, hence, in any finite way (assuming the Church-Turing thesis).</p>

<p>Later, we’ll say more about other ways of formulating Gödel’s First Incompleteness Theorem.</p>

<br>

<h2 id="section_importance">Philosophical Importance</h2>

<p>Gödel’s Theorem is important for many reasons. Firstly, it shows that we are able to frame questions about mathematics that we are <em>not</em> able to answer, by any computational means.</p>

<p><em>Maybe</em> it shows those questions don’t have answers; <em>maybe</em> it shows that there is a difference between being true and being provable, even in principle, by computational means.</p>

<p>Maybe it also shows that, even in the realm of mathematics, we can never be completely certain of our results.</p>

<p>Some people even think it shows that human minds are, fundamentally, non-computational!</p>

<p>We will discuss all of these possibilities once we are clear on why the theorem is true.</p>

</ul>

<br>

<h1 id="section_language">The Language of Arithmetic</h1>

<ul>

<h2 id="section_l">Introducing \(\mathcal{L}\)</h2>

<p>We will be proving that no Turing Machine outputs a &ldquo;\(1\)&rdquo; iff it is given an <strong>arithmetical sentence</strong> as input. But what is an arithmetical sentence? We could say: it is a sentence, in any normal language like English, that is about arithmetic. But it is hard to prove things about “arithmetical sentences” defined in that way, because it is hard to be precise about which strings of symbols, exactly, count as normal sentences, and which ones, exactly, are about arithmetic. Also, normal languages like English are <em>extremely complicated</em>, so even if we could get precise about what exactly would count as the sentences we are interested in, proving things about them would be <em>hard</em>.</p>

<p>To make life easier, we are going to invent a special language — one that is <em>much, much</em> simpler than English, or any other language people learn as babies. This language is going to have only one job: to say things about arithmetic. By “arithmetical sentence”, we will just mean a sentence in our invented language. We will call our language \(\mathbf{L}\).</p>

<p>We need to pick a particular language to prove Gödel’s Theorem, but, happily, Gödel&#8217;s Theorem is a pretty robust result, which doesn&#8217;t depend on the details of our language much.</p>

<br>

<h2 id="section_symbols">Symbols in \(\mathcal{L}\)</h2>

<p>Below is a complete list of the symbols in \(\mathcal{L}\):</p>
<center>
<table width="80%">
	<thead>
		<tr> <th>Symbol</th> <th>Type of Symbol</th> <th>Meaning</th> </tr>
	</thead>
	<tbody>
		<tr><td> \(\mathtt{0}\) </td> <td>arithmetical term</td> <td>“\(\mathtt{0}\)” names the number zero</td></tr>
		<tr><td> \(\mathtt{1}\)</td> <td>arithmetical term</td> <td> “\(\mathtt{1}\)” names the number one</td></tr>
		<tr><td> \(\mathtt{+}\)</td> <td>arithmetical term</td> <td> “\(\mathtt{+}\)” expresses addition</td></tr>
		<tr><td> \(\mathtt{\times}\)</td> <td>arithmetical term</td> <td> “\(\mathtt{\times}\)” expresses multiplication</td></tr>
		<tr><td> \(\mathtt{\hat{\mkern6mu}}\)</td> <td>arithmetical term</td> <td>“\(\mathtt{\hat{\mkern6mu}}\)” expresses exponentiation</td></tr>
		<tr> <td>\(\mathtt{=}\)</td> <td>logical relation</td> <td>&ldquo;\(\mathtt{=}\)&rdquo; expresses identity</td></tr>
		<tr><td> \(\mathtt{\neg}\) </td><td> logical operator </td><td> &ldquo;\(\mathtt{\neg}\)&rdquo; expresses negation</td></tr>
		<tr><td> \(\mathtt{\&amp;}\)</td> <td>logical operator</td> <td> &ldquo;\(\mathtt{\&amp;}\)&rdquo; expresses conjunction</td></tr>
		<tr><td> \(\mathtt{\forall}\) </td> <td>quantifier</td> <td>&ldquo;\(\mathtt{\forall}\)&rdquo; expresses universal quantification</td></tr>
		<tr><td> a variable \(\mathtt{x}_n\), for each natural number \(n\)</td> <td>variable</td> <td>[A variable is like aplace holder in the sentence for a name.<br> It doesn't refer to anything in particualr. I’ll say more about this later.]</td></tr>
		<tr><td> \(\mathtt{(}\) </td> <td> parenthesis </td> <td>[nothing]</td></tr>
		<tr><td> \(\mathtt{)}\) </td> <td> parenthesis </td> <td>[nothing]</td></tr>
	</tbody>
</table>
</center>
<p>Let me explain how each of these symbols is used.</p>

<ul>

<h3 id="section_arithmetical">Arithmetical Terms</h3>

<p>The arithmetical terms \(\mathtt{0}\), \(\mathtt{1}\), \(\mathtt{+}\), \(\mathtt{\times}\) and \(\mathtt{\hat{\mkern6mu}}\) work exactly as you’d expect: \(\mathtt{0}\) and \(\mathtt{1}\) name the numbers zero and one, respectively, and \(\mathtt{+}\), (\mathtt{\times}\) and \(\mathtt{\hat{\mkern6mu}}\) express addition, multiplication and exponentiation, respectively. (To improve readability, I will sometimes write \(\ulcorner n^m\urcorner\) instead of \(\ulcorner n\mathtt{\hat{\mkern6mu}}m\urcorner\).)</p>

<p>As it turns out, you don’t strictly need the exponentiation symbol to be in the language to prove the theorem. But it makes life a bit simpler in proving the Lemma below. So we’ll keep it in the language to make things easy on ourselves.</p>

<p>Using \(\mathtt{0}\), \(\mathtt{1}\), \(\mathtt{+}\), together with the parenthesis-symbols, we can form an expression to name any natural number we like. In particular:
	<ul>
		<li>\(\mathtt{0}\) names the number zero</li>
		<li>\(\mathtt{1}\) names the number one</li>
		<li>\(\mathtt{(1+1)}\) names the number two</li>
		<li>\(\mathtt{(1+1)+1}\) names the number three</li>
		<li>\(\mathtt{(((1+1)+1)+1)}\) names the number four</li>
		<li>etc.</li>
	</ul>
</p>

<p>To avoid clutter, we will introduce the following abbreviations:</p>
	<ul>
		<li>\(\mathtt{2}\) is an abbreviation for \(\mathtt{(1+1)}\)</li>
		<li>\(\mathtt{3}\) is an abbreviation for \(\mathtt{((1+1)+1)}\)</li>
		<li>\(\mathtt{4}\) is an abbreviation for \(\mathtt{(((1+1)+1)+1)}\)</li>
		<li>and so forth.</li>
	</ul>
</p>

<p>The parenthesis-symbols could have been avoided above. But it’s good practice to use them, because they’re sometimes needed to eliminate ambiguities. For instance, we want to distinguish between \[\mathtt{(2+2)\times 2}\] and \[\mathtt{2+(2\times 2)}\]</p>
<br>

<h3 id="section_identity">Identity</h3>

<p>The arithmetical terms we’ve discussed so far allow us to name numbers in all sorts of interesting ways. For instance, we can name the number two by using \(\mathtt{(1+1)}\) or \(\mathtt{(2 \times 1)}\). But we can’t make any arithmetical claims, that can be true or false, using just these terms.</p>

<p>In order to make claims, we need the symbol \(\mathtt{=}\), which expresses identity. Once we have \(\mathtt{=}\), \(\mathcal{L}\) is able to express true claims like \[\mathtt{2\times 1 = 1\times 2}\] or \[\mathtt{2\times(2+2)=(2\times 2)+ (2\times 2)}\] and false claims like \[\mathtt{2=3}\]</p>

<br>

<h3 id="section_logical">Logical Operators</h3>

<p>The symbols \(\mathtt{\neg}\) and \(\mathtt{\&amp;}\) express the logical operations of negation and conjunction, respectively.</p>

<p>You can read \(\mathtt{\neg}\) as &ldquo;It is not the case that&rdquo;. Accordingly, \(\mathcal{L}\) can express claims like \[\mathtt{\neg (1=2)}\](Read: &ldquo;It is not the case that one equals two.&rdquo;)</p>

<p>You can read \(\mathtt{\&amp;}\) as &ldquo;and&rdquo;. Accordingly, \(\mathcal{L}\) can express claims like \[\mathtt{(1+2=3) \ \&amp; \ (2+1=3)}\] (Read: &ldquo;One plus two equals three, and two plus one equals three&rdquo;.)</p>

<br>

<h3 id="section_variables">Variables and Quantifiers</h3>

<p>None of the symbols we have discussed so far enables us to express general statements. For instance, we are unable to state the commutativity of multiplication:</p>

<blockquote>
<p>For all numbers \(n\) and \(m\), the product of \(n\) and \(m\) equals the product of \(m\) and \(n\)</p>
</blockquote>

<p>The quantifier \(\mathtt{\forall}\) and the variables \(\mathtt{x_1}\), \(\mathtt{x_2}\), \(\mathtt{x_3}\), etc. can be used to express general claims of this kind.</p>

<p>\(\mathtt{\forall}\) means something like “For all numbers”. A variable, like \(\mathtt{x_0}\), is kind of like the word “it” in English. It’s a place-holder, where, if you didn’t use the “\(\mathtt{\forall}\)”, you could substitute a name for a particular thing.</p>

<p>Together, you can use \(\mathtt{\forall}\) and a variable to say something like: \[\mathtt{\forall x_0 (x_0 = x_0)}\] You can read this as “for all numbers \(x_0\), \(x_0\) equals \(x_0\)” — i.e., all numbers are such that they equal themselves.</p>

<p>The advantage of having variables with different indices is that we can have different “it”s in a single sentence without losing track of what refers to what. For instance, we can express the commutativity of multiplication as \[\mathtt{\forall x_1\forall x_2 (x_1\times x_2 = x_2\times x_1)}\] which you can read as:</p>

<blockquote>
<p>For all numbers \(x_1\) and for all numbers \(x_2\), \(x_1\) times \(x_2\) equals \(x_2\) times \(x_1\).</p>
</blockquote>

<p>— i.e., all pairs of numbers are such that the first times the second equals the second times the first.</p>

<br>

<h3 id="section_substitution">Formulas, Sentences, Binding and Substitution</h3>

<p>It will be helpful in what follows for you to know a little bit of terminology to speak about strings of symbols of \(\mathcal{L}\).</p>

<p>A <strong>formula</strong> is any old string of symbols of \(\mathcal{L}\). \(\mathtt{())0+\forall+}\) is a formula of \(\mathcal{L}\), and so is \(\mathtt{1=2 \&amp; 2=1}\). Some formulas make sense and some don’t. You can specify rules for making sentences of \(\mathcal{L}\) that guarantee that they make sense, but we won’t bother here; we’ll just assume, for the most part, that we’re talking about formulas that make sense.</p>

<p>A <strong>sentence</strong> of \(\mathcal{L}\) is a formula of \(\mathcal{L}\) that is either true or false.</p>

<p>All sentences are formulas, but not all formulas are sentences. Even some formulas that make perfect sense aren’t sentences. Here is an example: \[\mathtt{x_1 + x_1 = 1 + 1}\] That formula makes sense — it makes sense to say that a number has the property that this formula is talking about, for instance. But this formula can’t be true or false. Here is a formula that <em>can</em> be true or false: \[\forall x_1(x_1 +x_1 = 1+1)\]</p>

<p>Moral: a formula can only be a sentence if each variable in the formula has a corresponding \(\mathbb{\forall}\) somewhere in the formula. Otherwise, the formula, while making some sense, cannot be true or false.</p>

<p>When a variable has a corresponding \(\mathtt{\forall}\), that variable is said to be <strong>bound</strong>. When a variable <em>doesn’t</em> have a corresponding \(\mathtt{\forall}\), the variable is <strong>free</strong>.</p>

<p>Here is another example: \[\mathtt{\forall x_1 (x_1 \times x_2 = x_2 \times x_1)}\] This is <em>not</em> a sentence: the \(\mathtt{x_2}\) is free. One way to make it a sentence would be to do this: \[\mathtt{\forall x_1 \forall x_2 (x_1 \times x_2 = x_2 \times x_1)}\]</p>

<p>The last thing you need to know about is <strong>substitution</strong>. If you have a formula with an free variable in it, like \[\mathtt{\forall x_1 (x_1 \times x_2 = x_2 \times x_1)}\] you can turn it into a sentence by <em>substituting</em> a name for a number in the place where the unbound variable is. So if we used the name \(\mathtt{(1+1)}\), and substituted that for the variable \(\mathtt{x_2}\), the above formula would become the following sentence: \[\mathtt{\forall x_1 (x_1 \times (1+1) = (1+1) \times x_1)}\]</p>

</ul>

<br>

<h2 id="section_mighty">Simple Yet Mighty</h2>

<p>\(\mathcal{L}\) is very simple. But it is mighty! We can say a lot, using \(\mathcal{L}\). We can make relatively mundane arithmetical claims, like \(\mathtt{2 + 3 = 5}\). We can also make interesting, complicated claims, that have taken hundreds of years to prove, like <a href="https://en.wikipedia.org/wiki/Fermat%27s_Last_Theorem">Fermat’s Last Theorem</a>. We can even express things such that nobody knows whether they are true or false, like <a href="https://en.wikipedia.org/wiki/Goldbach%27s_conjecture">Goldbach’s Conjecture</a>.</p>

<p>How is it we can say so much? It is easier to see how it can be done if you allow yourself to define some new vocabulary, using the basic \(\mathcal{L}\) symbols.</p>

<ul>

<h3 id="section_defining">Defining New Vocabulary in \(\mathcal{L}\)</h3>

<p>When we define a new symbol, using the basic symbols of \(\mathcal{L}\), all we are doing is establishing a convention for abbreviating some string of \(\mathcal{L}\) symbols in a convenient way.</p>

<p>Even though that’s all we’re doing, this is extremely helpful, because sometimes certain strings of \(\mathcal{L}\) are very natural translations of English, and the kind of thing we want to be able to say over and over again.</p>

<p>For instance, we can introduce the notation \(\mathtt{exists x_0}, and define that as just an abbreviation for \(\mathtt{\neg\forall x_0 \neg}\). That is very helpful, because the string \(\mathtt{\neg\forall x_0 \neg}\)” is a good translation of the phrase “there exists a number \(x_0\) such that…” (though maybe you have to think about it a little bit to see that is true). </p>

<p>We want to be able to say that “there exists a number \(x_0\) such that…” all the time. Now we have the newly defined symbol \(\mathbb{exists x_0}\), we can go ahead and use it whenever we want to say “there exists a number \(x_0\) such that…”, without having to think through the fact that we could use \(\mathbb{\neg\forall x_0 \neg}\)” instead every time.</p>

<p>Here is a list of other very convenient things we can define in terms of the symbols of \(\mathcal{L}\):</p>
<center>
<table>
	<thead>
		<tr> <th>New Symbol</th> <th>Read</th> <th>Abbreviates</th> </tr>
	</thead>
	<tbody>
		<tr> <td>\(\mathtt{2}\)</td> <td>&ldquo;two&rdquo;</td> <td>\(\mathtt{(1 + 1)}\)</td> </tr>
		<tr> <td>\(\mathtt{3}\)</td> <td>&ldquo;three&rdquo;</td> <td>\(\mathtt{((1+1)+1)}\)</td> </tr>
		<tr> <td>\(\mathtt{4}\)</td> <td>&ldquo;four&rdquo;</td> <td>\(\mathtt{(((1+1)+1) + 1)}\)</td> </tr>
		<tr> <td>etc.</td> <td>etc.</td> <td>etc.</td> </tr>
		<tr> <td>\(\mathtt{\exists x_i}\)</td> <td>&ldquo;there exists a number \(x_i\) such that&rdquo;</td> <td>\(\mathtt{\neg \forall x_i \neg}\)</td> </tr>
		<tr> <td>\(A\mathtt{\vee} B\)</td> <td>&ldquo;\(A\) or \(B\)&rdquo;</td> <td>\(\mathtt{\neg(\neg} A \ \mathtt{\&amp;} \ \mathtt{\neg} B)\)</td> </tr>
		<tr> <td> \(A \mathtt{\supset} B\)<sup><a href="#fn:1" id="fnref:1" title="see footnote" class="footnote">1</a></sup></td> <td>&ldquo;if \(A\) then \(B\)&rdquo;</td> <td>\(\mathtt{(\neg} A\mathtt{) \vee} B\)</td></tr>
		<tr> <td>\(\mathtt{x}_i \mathtt{&lt; x}_j\)</td> <td>&ldquo;\(x_i\) is smaller than \(x_j\)&rdquo;</td> <td>\(\mathtt{\exists x_\mathit{k} ((x_\mathit{j} = x_\mathit{i} + x_\mathit{k}) \ \&amp; \ \neg(x_\it{k}= 0))}\)</td></tr>
	</tbody>
</table>
</center>

<p>That, of course, is just the beginning. We can keep defining stuff in terms of other stuff. We can define something that means “\(x_0\) is prime”. We can use that to express, for instance, Goldbach’s conjecture, or the twin prime conjecture. There’s no end of interesting things we can say in \(\mathcal{L}\).</p>

<p>The fact that \(\mathcal{L}\) is such an expressive language guarantees that if we were able to construct a Turing Machine that outputted every truth of \(\mathcal{L}\) (and no falsehoods), we would have succeeded in concentrating a huge wealth of mathematical knowledge in a finite list of lines of code. Implicit in our program would be not just all the arithmetic we learned in school, but also remarkable mathematical results. If we had a machine that outputted all and only the true sentences in \(\mathcal{L}\), then — since we can express, for example, Goldbach’s Conjecture in \(\mathcal{L}\) — we would have a way of knowing for certain whether Goldbach’s Conjecture is true.</p>

<p>Alas, Gödel’s Theorem shows that the dream of constructing such a machine is not to be…</p>

</uL>

</ul>

<br>

<h1 id="section_machines">Talking About Turing Machines in \(\mathcal{L}\)</h1>

<p>Here is an amazing fact. You can use \(\mathcal{L}\) to talk about Turing Machines! For instance, you can write down a sentence of \(\mathcal{L}\) that is true if and only if a certain Turing Machine computes a certain function.</p>

<p>How on Earth is that possible? \(\mathcal{L}\) doesn’t have any symbols that refer to Turing Machines, or tapes, or anything like that!</p>

<p>It’s possible because one can use numbers to <em>code</em> information about Turing Machines.</p>

<p>I’ll tell you all about the relevant coding tricks in this subsection, and we’ll prove the following Lemma:</p>

<blockquote>
<p><strong>Lemma</strong><br>
We can define a formula \(\mathtt{Validate(x_1,x_2)}\), which is true if and only if Turing Machine number \(x_1\), validates the sentence of \(\mathcal{L}\) encoded by \(x_2\)</p>
</blockquote>

<p>Proving this lemma is the hardest part of proving Gödel’s Theorem. We won’t do it in full detail; I’ll just tell you enough to give you the idea. Don’t sweat these details too much, if you find it hard. The really interesting part of Gödel’s Theorem is what comes after the Lemma; make sure you have <em>that</em> part down.</p>

<ul>

<h2 id="section_sequences">Sequences</h2>

<p>The key to it all, it turns out, is to be able to express claims about <em>sequences of numbers</em>, in \(\mathcal{L}\).</p>

<p>Specifically, we need a formula, which we can call \[\mathtt{Sequence}(\mathit{c},\mathit{n},\mathit{a},\mathit{i})\] which is true if and only if a number \(c\) encodes a sequence of numbers length \(n\) of which \(a\) is the (\i\)-th member.</p>

<p>What do we mean, when we say \(c\) encodes a sequence of numbers? We need to pick some particular way of encoding sequences of numbers as one number. We talked about one such way in Topic 8; we will do so again here, briefly, below.</p>

<p>Anyway, once we’re equipped with our \(\mathtt{Sequence}(\mathit{c},\mathit{n},\mathit{a},\mathit{i})\) formula, it’ll be very easy to use \(\mathcal{L}\) to say things about Turing Machines, because we’ll be able to represent Turing Machines as number-sequences of a particular sort.</p>

<p>We won't do all the details, but below I'll give you a feel for how \(\mathtt{Sequence}(\mathit{c},\mathit{n},\mathit{a},\mathit{i})\) works.</p>

<ul>

<h3 id="section_pairs">Pairs</h3>

<p>Let us start with the relatively simple task of using \(\mathcal{L}\) to express claims about sequences of length two — that is, claims about ordered pairs. In other words: we’ll see how to use a natural number \(x_0\) to encode an ordered pair of natural numbers \(\langle x_1,x_2\rangle\). And we’ll see how to write down a sentence of \(\mathcal{L}\) which is true if and only if \(x_0\) encodes the ordered pair \(\langle x_1,x_2\rangle\).</p>

<p>Let’s start with the coding scheme. We can use more or less the same coding scheme we used back in Topic 8, when we wanted to encode command lines. That is, we can code \(\langle x_1, x_2\rangle\) as \(2^{x_1} \times 3^{x_2}\). (Back in Topic 8, we encoded \(\langle x_1, x_2\rangle\) as \(2^{x_1+1} \times 3^{x_2+1}\); we don’t need to add the \(1\) here, so we won’t.)</p>

<p>So much for our coding-scheme. Let’s now see how facts about which numbers code which pairs can be expressed within \(\mathcal{L}\).</p>

<p>On the coding scheme we just discussed, \(12\) is used to code \(\langle 2, 1\rangle\), because \(12 = 2^2 \times 3^1\). Suppose that we want to find a sentence of \(\mathcal{L}\) that expresses this fact. What we want, in other words, is sentence of \(\mathcal{L}\) that is true if and only if \(12 = 2^2\times 3^1\). But that is easily done, since the following is a sentence of \(\mathcal{L}\): \[\mathtt{12 = 2^2 \times 3^1}\] (We've used some defined terms, which, remember, are just abbreviations for symbols in \(\mathcal{L}\).)</p>

<p>More generally, we can use \[\mathtt{x_0=2^{x_1}\times 3^{x_2}}\]to express the fact that \(x_0\) encodes the ordered pair \(\langle x_1,x_2\rangle\).</p>

<p>Let us use \(\mathtt{Pair(x_0,x_1,x_2)}\) as an abbreviation for \(\mathtt{x_0=2^{x_1}\times 3^{x_2}}\). Equivalently:\[\mathtt{Pair(x_0,x_1,x_2)} \leftrightarrow_{df} \mathtt{x_0=2^{x_1}\times 3^{x_2}}\]</p>

<p>Now that we have \(\mathtt{Pair(x_0,x_1,x_2)}\) in place, we can use it to express other claims about pairs. For example, we can define a formula \[\mathtt{First(x_0,x_1)}\] that is true if and only if \(x_0\) codes a pair of which \(x_1\) is the first member: \[\mathtt{First(x_0,x_1)} \leftrightarrow_{df} \mathtt{\exists x_2 (Pair(x_0,x_1,x_2))} \]</p>

</ul>

<br>

<p>We have now seen how to use \(\mathcal{L}\) to talk about sequences of length two (that is, ordered pairs).</p>

<p>The same technique can be used for sequences of any <em>particular</em> length. So, for instance, one can encode the triple \(\langle a,b,c\rangle\) as \(2^a\times 3^b\times 5^c\) and use the following formula to express the claim that \(x\) encodes the triple \(a,b,c\): \[\mathtt{x = 2^\mathit{a}\times 3^\mathit{b} \times 5^\mathit{c}}\]</p>

<p>What we need to prove the theorem, however, is a single formula that allows us to talk about sequences of <em>any</em> finite length. We need a formula \(\mathtt{Sequence(\mathit{c},\mathit{n},\mathit{a},\mathit{i})}\) which is true if and only if \(c\) encodes an sequence of length \(n\) (an \(n\)-tuple) of which (a) is the (i)-th member.</p>

<p>That is actually quite tricky; I won’t go into the details here. But it is within reach, for any of you who have some familiarity with first-order logic. It is an excellent exercise to try to define \(\mathtt{Sequence(\mathit{c},\mathit{n},\mathit{a},\mathit{i})}\)!</p>

<ul>

<h3 id="section_onemore">One More Useful Formula</h3>

<p>The details of how to do this depend on the details of how we define \(\mathtt{Sequence(\mathit{c},\mathit{n},\mathit{a},\mathit{i})}\), but I will just report that we can also define the following formula, which will be useful later:</p>

<blockquote>
<p>\(\mathtt{Seq(\mathit{c}, \mathit{n})}\), which is true if and only if number \(c\) encodes a sequence of \(n\) numbers.</p>
</blockquote>

</ul>

<br>

<h2 id="section_tms">Turing Machines</h2>

<p>\(\mathtt{Sequence(\mathit{c},\mathit{n},\mathit{a},\mathit{i})}\) is incredibly powerful. We can say <em>a lot</em> with it. Among other things, we can say basically everything there is to say about Turing Machines.</p>

<ul>

<h3 id="section_command">Command Lines</h3>

<p>As we know, we can code a command line in a Turing Machine program as a sequence of numbers. So, using \(\mathtt{Sequence(\mathit{c},\mathit{n},\mathit{a},\mathit{i})}\), and also \(\mathtt{Seq(\mathit{c}, \mathit{n})}\), we can write down a sentence of \(\mathcal{L}\) that is true if and only if a number encodes a possible command line of a Turing Machine.</p>

<p>It looks like this:</p>

<blockquote>
<p>\(\mathtt{Seq(x_1,5) \ \&amp;}\)</p>

<p>\(\mathtt{\forall x_3 (Sequence(x_1,5,x_3,2) \supset x_3 \leq 12) \ \&amp;}\)</p>

<p>\(\mathtt{\forall x_3 (Sequence(x_1,5,x_3,3) \supset x_3 \leq 12) \ \&amp;}\)</p>

<p>\(\mathtt{\forall x_3 (Sequence(x_1,5,x_3,4) \supset x_3 \leq 2)} \)</p>

</blockquote>

<p>What does this formula say? First, it verifies that \(x_1\) codes a sequence of length 5. Then it verifies that the second element of the sequence is a number less than \(12\), that the third element of the sequence is a \(0\) or \(1\), and that the fourth element of the sequence is a \(0\), \(1\), or \(2\).</p>

<p>And why do we want the formula to say this? Remember that any command line of a Turing Machine can be expressed as a five-element sequence: The first element is the state the Turing Machine is in, so it can be any natural number. The second element is the symbol the machine reads. The Turing Machine we want to talk about takes sentences of \(\mathcal{L}\) as input, and \(\mathcal{L}\) has 12 symbols in it, plus a blank, so we use numbers 0-12 to code those symbols. The third element is the symbol with which the machine replaces the symbol it read: again, either a blank or one of the symbols of \(\mathcal{L}\). The fourth element says in which direction the machine should move: L (left), R (right), and * (do not move) are possible, where L is represented by 0, R is represented by 1, and * is represented by 2. The fifth element is the state the Turing Machine then enters, which can again be any natural number.</p>

<p>We can call the above formula of \(\mathcal{L}\) \(\mathtt{ValidCommand(x_1)}\)</p>

<br>

<h3 id="section_programs">Programs</h3>

<p>A Turing Machine program is just a sequence of command lines. Each command line can be coded as a number, so an entire Turing Machine program can be coded as a sequence of numbers, each of which encodes a command line. And that sequence of numbers can again be coded as a single number, in exactly the same way you encode any sequence of numbers.</p>

<p>Given all this, it is again relatively easy to write down a sentence \(\mathtt{ValidProgram(x_1)}\) that is true if and only \(x_1\) encodes a valid Turing Machine program.</p>

<br>

<h3 id="section_tape">The Tape</h3>

<p>We can use \(\mathcal{L}\) to describe a Turing Machine program. So we are very close to being able to use \(\mathcal{L}\) to describe a running Turing Machine. All that is missing is the Turing Machine’s input and output — i.e., its tape. But that’s easily fixed; the tape can easily be encoded as a sequence of numbers, just like everything else!</p>

<p>For convenience, we will assume that the tape is infinitely long in only one direction, and that at any one time, there are at most finitely many non-blanks on the tape. We don’t lose any generality assuming this, as anything that can be computed using a two-way infinite tape, with infinite non-blanks, can be computed on our one-way infinite tape with finite non-blanks.</p>

<p>That being so, the state of our tape can straightforwardly be represented as a finite sequence of numbers, with the first number representing the first symbol on the tape, the second number the second symbol, and so forth.</p>

<p>We will need to come up with a scheme for coding symbols on the tape as numbers, but that is easy. We just use a different number for each possible symbol.</p>

<p>So, we can, using the same tricks we already know, encode our sequence as a number, and write down a sentence \(\mathtt{ValidTape(x_1)}\) of \(\mathcal{L}\) that is true if and only if \(x_1\) encodes a sequence that corresponds to a possible state of a tape.</p>

</ul>

<br>

<h2 id="section_running">Running the Machine</h2>

<p>We have the tools to describe each piece of a Turing Machine. Now we find ways to describe how the Turing Machine <em>runs</em> over time.</p>

<ul>

<h3 id="section_moments">Turing Machine Moments</h3>

<p>The first step is to define a formula \(\mathtt{MachineMoment(x_0)}\) which represents the exact status of a Turing Machine at a particular moment in time.</p>

<p>We want \(\mathtt{MachineMoment(x_0)}\) to be true just in case \(x_0\) codes a sequence of numbers \(\langle x_1,x_2,x_3,x_4 \rangle\) such that:</p>

<ul>
<li>\(\mathtt{ValidProgram(x_1)}\) (i.e. \(x_1\) encodes a valid Turing Machine program),</li>
<li>\(x_2\) is an arbitrary number (which will be used to represent a Turing Machine state),</li>
<li>\(\mathtt{ValidTape(x_3)}\) (i.e. \(x_3\) encodes a valid Turing Machine tape), and</li>
<li>\(x_4\) is an arbitrary number (which will be used to represent a position of the reader on the tape).</li>
</ul>

<br>

<h3 id="section_special">Special Moments</h3>

<p>We now define two formulas \(\mathtt{InitialMoment(x_0, x_1, x_2)}\) and \(\mathtt{HaltingMoment(x_0)}\).</p>

<p>\(\mathtt{InitialMoment(x_0, x_1, x_2)}\) is true iff
	<ul>
		<li> (\mathtt{MachineMoment(x_0)}\) (i.e. \(x_0\) encodes a Turing Machine moment),</li>
		<li> the machine moment encoded by \(x_0\) is the sequence \(\langle x_1, 0, x_2, 0\rangle\) (i.e. \(x_0\) represents a machine moment corresponding to a machine with program \(x_1\) in state 0, with initial tape encoded by \(x_2\) and with the reader at the beginning of the tape).</li>
	</ul>
</p>

<p>\(\mathtt{HaltingMoment(x_0)}\) is true just in case:</p>

<ul>
<li>\(\mathtt{MachineMoment(x_0)}\) (i.e. \(x_0\) encodes a Turing Machine moment), and</li>
<li>the Turing Machine moment encoded by \(x_0\) is such that the machine is in a state and reading a symbol for which it has no command line.</li>
</ul>

<br>

<h3 id="section_step">Step By Step</h3>

<p>Now for something magical: a formula \(\mathtt{Step(x_1,x_2)}\) which is true if and only if:</p>

<ul>
<li>\(\mathtt{MachineMoment(x_1)}\),</li>
<li>\(\mathtt{MachineMoment(x_2)}\), and</li>
<li>the Turing Machine moment encoded by \(x_2\) is exactly the Turing Machine moment you would get if you advanced one step from the Turing Machine moment encoded by \(x_1\).</li>
</ul>

<p>Suppose, for instance, that \(x_1\) encodes a Turing machine moment whereby a machine which includes command line</p>
<blockquote>
<p>4 _ _ r 6</p>
</blockquote>
<p>is in state 4, and reading a blank on position 17 of the tape. Then \(\mathtt{Step(x_1,x_2)}\) can only be true if \(x_2\) encodes a Turing Machine moment whereby that same machine with that same tape is in state 6, on position 18 of the tape.</p>

<p>Once we have \(\mathtt{Step(x_1,x_2)}\) in place, we can use it to define a formula \(\mathtt{RunSequence(x_1,x_2,x_3}\) which is true just in case:</p>

<ul>
<li>\(x_1\) encodes a finite sequence of Turing moments \(m_0,m_1,\ldots,m_k\),</li>
<li>\(\mathtt{InitialMoment(\mathit{m_0},x_2,x_3)}\) (i.e. \(m_0\) encodes a machine moment consisting of a Turing Machine with program \(x_2\), in state 0, at the begining of the tape encoded by \(x_3\)).</li>
<li>\(\mathtt{Step(\mathit{m_i},\mathit{m_{i+1}})}\) holds for each \(i &lt; k\)</li>
<li>\(\mathtt{HaltingMoment(\mathit{m_k})}\)</li>
</ul>

</ul>

<br>

<h2 id="section_validate">Validate</h2>

<p>And now, the pièce de résistance. All the pieces are in place. We can define a formula \(\mathtt{Validate(x_1,x_2)}\), which is true if and only if Turing Machine \(x_1\) validates the input encoded by \(x_2\).</p>

<p>It is defined thus:
	<ul>
		<li>\(\mathtt{\exists x_3 (RunSequence(x_3, x_1, x_2)}\), and</li>
		<li>the last Turing Machine-moment encoded by \(x_3\) has a \(\mathtt{1}\) on the tape, and nothing else.</li>
	</ul>
</p>

</ul>
<br>

<h1 id="section_proved">Gödel’s First Incompleteness Theorem Proved</h1>

<ul>

<h2 id="section_using">Using \(\mathcal{L}\) to talk about \(\mathcal{L}\)</h2>

<p>In the course of the arduous proof-sketch of our lemma above, we said that we needed a code for the stuff on the tape. Something that can appear on the tape is formulas of \(\mathcal{L}\). We could as easily code up a formula of \(\mathcal{L}\) as any other string of symbols that can appear on our tape. This means we can use \(\mathcal{L}\) <em>to talk about sentences of \(\mathcal{L}\)</em>. We don’t do it directly; instead, we use numbers that encode sentences of \(\mathcal{L}\).</p>

<p>We’re going to combine our powers to talk about Turing Machines in \(\mathcal{L}\), and to talk about \(\mathcal{L}\) in \(\mathcal{L}\), to prove Gödel’s First Incompleteness Theorem</p>

<br>

<h2 id="section_overview">Overview of the Proof</h2>

<p>The idea is to create a sentence \(\mathtt{G}\) in the language of arithmetic which is true if and only if it is <em>not</em> the case that our Turing Machine validates \(\mathtt{G}\), when given \(\mathtt{G}\) as input. We will call \(\mathtt{G}\) the <strong>Gödel sentence</strong>.</p>

<p>The existence of the Gödel sentence, together with the assumption that our magical Turing Machine validates all and only the true sentence of \(\mathcal{L}\), entails a contradiction .</p>

<p>How? Well suppose the Gödel sentence is true. Then, our magic Turing Machine should validate it. But the Gödel sentence is true only if the magic Turing Machine <em>doesn’t</em> validate it. Contradiction!</p>

<p>So suppose the Gödel sentence is false. Then, the magic Turing Machine should <em>not</em> validate it. But that’s what the Gödel sentence says, which means it is true. Contradiction!</p>

<p>So either way, there’s a contradiction.</p>

<p>So our assumption that there is a Turing Machine that validates all and only the true sentences of \(\mathcal{L}\) cannot be true.</p>

<p>Now I’ll show you how to define the Gödel sentence.</p>

<br>

<h2 id="section_sentence">The Gödel Sentence</h2>

<p>What we’d <em>like</em> to do is define the Gödel sentence as something like this: \[\mathtt{\neg Validate(\mathit{m}, \mathit{k})}\] where \(m\) is the number of the magic Turing machine, and \(k\) is the number that encodes the sentence \(\mathtt{\neg Validate(\mathit{m}, \mathit{k})}\) itself. The problem with this strategy is that there is no guarantee that we can find a \(k\) that makes that work.</p>

<p>So we'll have to be a bit clever. Actually, very clever. We will find an <em>indirect</em> way for a sentence to refer to itself, which is guaranteed to work.</p>

<ul>

<h3 id="section_coded">Subsitution Coded</h3>

<p>Remember substitution? That is a way of turning a formula with an unbound variable in it into a sentence. We’re going to use \(\mathcal{L}\) to talk about that. </p>

<p>More specifically, we’re going to define a formula \(\mathtt{Sub(x_1, x_2, x_3)}\) which is true iff:
<ol>
	<li>\(x_2\) encodes a formula of \(\mathcal{L}\) with one free variable in it;</li>
	<li>\(x_3\) encodes a sentence of \(\mathcal{L}\); and</li>
 	<li>the sentence \(x_3\) encodes is what you get by substituting the \(\mathcal{L}\)-name of \(x_1\) into the free variable in the formula encoded by \(x_2\).</li>
 </ol>
</p>

<p>(I don’t offer a proof that \(\mathtt{Sub(x_1, x_2, x_3)}\) can be defined, but just because it’s tedious, not because its hard. If you’re keen, give proving it a go!)</p>

<p>Note that nothing stops us from considering cases like \(\mathtt{Sub(x_1, x_1, x_2)}\) — that is, cases in which \(x_1\) encodes an open formula of \(\mathcal{L}\), and the result of substituting the \(\mathcal{L}\)-name of that very number, \(x_1\), into that formula, is the sentence encoded by \(x_2\). (Did I just blow your mind?)</p>

<br>

<h3 id="section_completed">The Proof Completed</h3>

<p>Suppose there is a Turing Machine that validates all and only the true sentences of \(\mathcal{L}\). Let us suppose it is Turing Machine number \(m\).</p>

<p>Now consider the formula \[\mathtt{Gödel(x_1)} \leftrightarrow_{df} \mathtt{\forall x_2 (Sub(x_1, x_1, x_2)\supset \neg Validate(\mathit{m}, x_2))}\] That is, for all numbers \(x_2\), if that number encodes a sentence that is the result of subtituting the \(\mathcal{L}\)-name for \(x_1\) into the formula that \(x_1\) encodes, then the magical Turing Machine does <em>not</em> validate the sentence encoded by \(x_2\).</p>

<p>Take a moment to understand that.</p>

<p>Ok. Now: \(\mathtt{Gödel(x_1)}\) has a its own code number. Call it “\(k\)”.</p>

<p>Consider \(\mathtt{Gödel(\mathit{k})}\). \(\mathtt{Gödel(\mathit{k})}\) is our Gödel sentence.</p>

<p>\(\mathtt{Gödel(\mathit{k})}\) says: it is not the case that the magic Turing Machine validates the sentence encoded by (the formula encoded by \(k\), with the name for number \(k\) substituted into that formula). But \(k\) encodes \(\mathtt{Gödel(x_1)}\). So the name of \(k\) substituted into the formula encoded by \(k\) is \(\mathtt{Gödel(\mathit{k})}\)! So \(\mathtt{Gödel(\mathit{k})}\), in effect, says: the magic Turing Machine doesn’t validate <em>me</em>!</p>

<p>That entails a contradiction. That proves Gödel’s First Incompleteness Theorem.</p>

<div class="footnotes">
<hr />
<ol>

<li id="fn:1">
<p>We’re using \(\mathtt{\mathit{A} \supset \mathit{B}}\) as an abbreviation for \(\mathtt{\neg(\neg \mathit{A} \ \&amp; \ \neg \mathit{B})}\). I say, above, that you can think of this string as a translation of the English “if \(A\) then \(B\)”. But actually, this is a very poor translation of that phrase in English. It is close enough, however, for our purposes; all that matters, for us, is that \(\mathtt{\mathit{A} \supset \mathit{B}}\) entails that it can’t be that \(A\) is true and \(B\) is false, which is close enough to what we mean by “If \(A\) then \(B\)”, when it comes to mathematics. <a href="#fnref:1" title="return to article" class="reversefootnote">&#160;&#8617;</a></p>
</li>


</ol>
</div>


</body>
</html>